<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java对象类型转换</title>
      <link href="/2021/08/16/java-dui-xiang-lei-xing-zhuan-huan/"/>
      <url>/2021/08/16/java-dui-xiang-lei-xing-zhuan-huan/</url>
      
        <content type="html"><![CDATA[<h1 id="Java对象类型转换"><a href="#Java对象类型转换" class="headerlink" title="Java对象类型转换"></a>Java对象类型转换</h1><p>将一个类型强制转换成另一种类型的过程被称为类型装换。而Java中的对象类型转换，必须是有继承关系的对象，而不能是任意类型的对象。</p><p>如果对不存在继承关系的对象进行强制类型转换，会抛出强制类型转换异常（java.lang.ClassCastException）。</p><p>Java 语言允许某个类型的引用变量引用子类的实例，而且可以对这个引用变量进行类型转换。Java 中引用类型之间的类型转换（前提是两个类是父子关系）主要有两种，分别是向上转型（upcasting）和向下转型（downcasting）。</p><h2 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h2><p>父类引用指向子类对象为向上转型，语法格式如下：</p><pre class=" language-java"><code class="language-java">FatherClass obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SonClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>其中，FatherClass 是父类名称或接口名称，SonClass 是子类名称。obj 是根据 SonClass 这个子类模板创建出的对象。</p><p>向上转型就是把子类对象直接赋给父类引用，不用强制转换。使用起来有以下几点注意事项：</p><ol><li>使用向上转型可以调用父类类型中的所有成员方法，但不能调用子类类型中特有的成员方法。</li><li>当出现子类重写的情况，最终运行效果看子类的具体实现。</li></ol><h2 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h2><p>子类引用指向父类对象，称为向下转型，需要强制转换。</p><p>强制向下转型有两种方式：</p><ul><li><p>不安全的向下转型：如<code>Dog dog = (Dog) new Animal();</code>编译通过，但运行会抛出异常；</p></li><li><p>安全的向下转型：先向上转型，再向下转型，如:</p><pre class=" language-java"><code class="language-java">Animal animal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> Dog dog <span class="token operator">=</span> <span class="token punctuation">(</span>Dog<span class="token punctuation">)</span> animal<span class="token punctuation">;</span></code></pre></li></ul><p>这样做有什么意义呢？见下面示例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Game</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">playGame</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"打开电脑"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Csgo</span> <span class="token keyword">extends</span> <span class="token class-name">Game</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">playGame</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">playGame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"射击！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">LoL</span> <span class="token keyword">extends</span> <span class="token class-name">Game</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">playGame</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">playGame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"补兵！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Player</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">playGame</span><span class="token punctuation">(</span>Game game<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//通过instanceof来判断</span>        <span class="token comment" spellcheck="true">//参数为猫类对象的向上转型</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>game <span class="token keyword">instanceof</span> <span class="token class-name">Csgo</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Csgo csgo <span class="token operator">=</span> <span class="token punctuation">(</span>Csgo<span class="token punctuation">)</span> game<span class="token punctuation">;</span>            csgo<span class="token punctuation">.</span><span class="token function">playGame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>game <span class="token keyword">instanceof</span> <span class="token class-name">LoL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            LoL lol <span class="token operator">=</span> <span class="token punctuation">(</span>LoL<span class="token punctuation">)</span> game<span class="token punctuation">;</span>            lol<span class="token punctuation">.</span><span class="token function">playGame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Player player <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Player</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 传入不同的子类对象，在调用playGame时隐式的进行了向上转型</span>        player<span class="token punctuation">.</span><span class="token function">playGame</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Csgo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"*******************"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        player<span class="token punctuation">.</span><span class="token function">playGame</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LoL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>C<span class="token operator">:</span>\code\ide\java\jdk1<span class="token number">.8</span>\bin\java<span class="token punctuation">.</span>exe <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>打开电脑射击！<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>打开电脑补兵！</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发（一）线程安全与共享资源</title>
      <link href="/2021/07/06/java-bing-fa-yi-xian-cheng-an-quan-yu-gong-xiang-zi-yuan/"/>
      <url>/2021/07/06/java-bing-fa-yi-xian-cheng-an-quan-yu-gong-xiang-zi-yuan/</url>
      
        <content type="html"><![CDATA[<h1 id="Java并发（一）线程安全与共享资源"><a href="#Java并发（一）线程安全与共享资源" class="headerlink" title="Java并发（一）线程安全与共享资源"></a>Java并发（一）线程安全与共享资源</h1><p>​    能够安全的同时被多个线程同时调用的代码叫做<code>线程安全</code>。一段代码是<code>线程安全</code>的，等价于这段代码不包含<code>race conditions</code>（竞争条件）。而竞争条件只可能发生在多个线程同时更新<code>共享资源</code>的时候。因此为了我们的<code>线程安全</code>，很有必要知道线程在执行的时候共享了哪些资源。</p><h2 id="本地原始类型变量（local-primitive-variables）"><a href="#本地原始类型变量（local-primitive-variables）" class="headerlink" title="本地原始类型变量（local primitive variables）"></a>本地原始类型变量（local primitive variables）</h2><p>本地变量指定义在方法体内的变量。本地变量存储在每个线程私有的线程栈中，线程之间不会共享线程栈中的变量。这代表着所有的<code>本地原始类型变量</code>是线程安全的。下面是<code>本地原始类型变量</code>的例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">demoMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> threadSafeInt <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    threadSafeInt<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="本地对象引用（local-object-references）"><a href="#本地对象引用（local-object-references）" class="headerlink" title="本地对象引用（local object references）"></a>本地对象引用（local object references）</h2><p>本地对象引用与本地原始类型变量略有不同。引用本身同样是存储在线程栈中，且不共享的。但引用的那个对象是存储在堆中的（所有的对象存储在堆中）因此如果有多个线程能够访问到这个对象，那么这个对象是共享资源，不是线程安全的。</p><h2 id="对象成员变量（Member-variables-fields）"><a href="#对象成员变量（Member-variables-fields）" class="headerlink" title="对象成员变量（Member variables / fields）"></a>对象成员变量（Member variables / fields）</h2><p>对象的成员变量和对象一起存储在堆中。因此如果两个线程调用同一个对象实例的同一个方法（最常见的：使用同一个runnable实例【注：runnable实例指实现Runnable接口的实现类的实例】创建线程，两个线程调用start()方法后调用的是同一个对象实例的run()方法），而这个方法更新了对象的成员变量，那这个方法不是线程安全的。因为多个线程在同时更新<code>共享资源</code>。下面是一个不太常见的例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SharedMemberVariable</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        NotThreadSafe shareInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NotThreadSafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span>shareInstance<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span>shareInstance<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">MyRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    NotThreadSafe instance <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">MyRunnable</span><span class="token punctuation">(</span>NotThreadSafe instance<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>instance <span class="token operator">=</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>instance<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"一段文本"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">NotThreadSafe</span> <span class="token punctuation">{</span>    StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// StringBuilder不是线程安全的</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>String text<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在这个例子中，虽然两个线程使用的是两个不同的Runnable实例，但在两个Runnable实例调用run()方法的时候，两个Runnable实例的this.instance指向的是堆中同一个NotThreadSafe对象：shareInstance。因此两个线程调用同一个对象实例(shareInstance)的同一个方法(add(String text)方法)，而这个方法更新了对象的成员变量(sb)，那这个方法不是线程安全的。</p><p>然而，如果两个线程是在不同的实例上同时调用的add()方法，就不会构成竞争条件，比如这样稍微改动一下：</p><pre class=" language-Java"><code class="language-Java">new Thread(new MyRunnable(new NotThreadSafe())).start();new Thread(new MyRunnable(new NotThreadSafe())).start();</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 内存模型（JMM）</title>
      <link href="/2021/06/23/java-nei-cun-mo-xing-jmm/"/>
      <url>/2021/06/23/java-nei-cun-mo-xing-jmm/</url>
      
        <content type="html"><![CDATA[<h1 id="Java并发（二）Java内存模型"><a href="#Java并发（二）Java内存模型" class="headerlink" title="Java并发（二）Java内存模型"></a>Java并发（二）Java内存模型</h1><p>JVM（Java virtual machine）是对一个完整的计算机的建模，所以自然包括一个内存模型-也就是本文介绍的Java内存模型（Java memory medel）</p><p>在JVM内部，Java内存模型将内存分成thread stacks和heap，逻辑上的内存模型如下图：</p><p><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-1.png" alt=""></p><p>每一个在JVM中运行的thread都有一个独立的thread stack，thread stack包含了一个线程执行到当前位置，调用了哪些方法的相关信息。thread stack在 Jakob Jenkov 的文章中也叫做call stack。按照我的理解，thread stack = 虚拟机栈（JVM内存结构的概念）。在线程执行的过程中，thread stack是一直变化的。</p><p>此外，thread stack中包含了此线程执行到当前位置时，调用过的所有方法中的所有local variables。两个线程执行同样的代码段，也会将这段代码中出现的local variables在自己的thread stack中独立的创建一份。而每个线程只能访问自己的thread stack，所以一个线程创建的local variables对其他的所有线程都不可见。</p><p>基本定义：</p><p>本地变量：local variable，表示方法内部定义的变量。</p><p>成员变量：member variable，表示一个类的成员变量，通过类的实例访问。</p><p>类变量（静态变量）：class variabe/static class variable：表示一个类的静态变量，通过类访问。</p><table><thead><tr><th align="center">变量类型</th><th align="center">存放位置</th></tr></thead><tbody><tr><td align="center">本地变量：原始类型</td><td align="center">完全存在线程栈中</td></tr><tr><td align="center">本地变量：引用类型</td><td align="center">本地变量（即引用）存在线程栈中，引用的对象存在heap中</td></tr><tr><td align="center">成员变量</td><td align="center">随着对象存在heap中</td></tr><tr><td align="center">类变量</td><td align="center">随着class definiton存在heap中</td></tr></tbody></table><p>由于原始类型 ( boolean, byte, short, char, int, long, float, double)的本地变量完全存放在线程栈中，所以一个线程的原始类型的本地变量完全不能和其他线程共享，只能通过<code>pass a copy</code>给别的线程。</p><p>而heap上存放的是你的Java应用创建的<code>所有对象</code>。</p><ul><li>无论是哪个线程创建的</li><li>也不管这个对象是分配给一个方法中的本地变量，还是分配给另一个对象的成员变量。</li></ul><p>heap上的对象能被所有线程访问（只要这个线程拥有这个对象的引用）。而一个线程拥有了一个对象的访问权，也就拥有了这个对象的成员变量的访问权。因此如果两个线程同时调用同一个对象的方法，那么这两个线程都可以访问这个对象的成员变量。（但两个线程会对本地变量做独立的拷贝）</p><p>下面是一个例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ShareThreadTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ShareThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"Thread1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread thread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ShareThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"Thread2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">ShareThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">methodA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> localVariable1 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        ShareObject localVariable2 <span class="token operator">=</span> ShareObject<span class="token punctuation">.</span>shareInstance<span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread:"</span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"localVariable2:"</span> <span class="token operator">+</span> localVariable2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// ... do more with local variables</span>        <span class="token function">methodB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Integer localVariable1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">998</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// ... do more with local variable</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">ShareObject</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> ShareObject shareInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ShareObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>output<span class="token operator">:</span>Thread<span class="token operator">:</span>Thread2localVariable2<span class="token operator">:</span>JavaDemo<span class="token punctuation">.</span>MultiThread<span class="token punctuation">.</span>ShareObject<span class="token annotation punctuation">@23cebe71</span>Thread<span class="token operator">:</span>Thread1localVariable2<span class="token operator">:</span>JavaDemo<span class="token punctuation">.</span>MultiThread<span class="token punctuation">.</span>ShareObject<span class="token annotation punctuation">@23cebe71</span>Process finished with exit code <span class="token number">0</span></code></pre><p>两个线程在执行run()方法的时候，会调用methodA()方法。methodA()方法声明了两个本地变量。因此任何线程在执行到methodA()方法时，会在自己的线程栈中独立的复制一份<code>localVariable1</code>和 <code>localVariable2</code>的拷贝。其中，由<code>localVariable1</code>拷贝出的变量是完全独立的，线程a看不到另一个线程b对线程b自己的<code>copy of localVariable1</code>做出的修改。</p><p>而在两个线程栈中，虽然也独立的拷贝了<code>localVariable2</code>，但这两个拷贝复制的是指向堆上同一个对象的引用。</p><p>注意在methodB()方法中，创建了一个<code>localVariable1</code>本地变量，它是一个Integer类型对象的引用。由于这个方法每次执行的时候都会创建一个新的Integer对象，因此两个线程执行到这个方法，会创建不同的Integer实例，然后把引用复制到线程栈中。</p><p>整个过程对应下图：</p><p><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-3.png" alt=""></p><h1 id="计算机硬件内存架构"><a href="#计算机硬件内存架构" class="headerlink" title="计算机硬件内存架构"></a>计算机硬件内存架构</h1><p>现代的计算机硬件内存架构与Java内部的内存模型不太一样。由于我们的应用最终是运行在真实的计算机内存中，所以我们需要了解通用的硬件内存架构，以及我们的Java内存模型是如何与它共同工作的。</p><p>下面是一张简化的现代计算机硬件架构图：</p><p><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-4.png" alt=""></p><p>现代计算机通常有多个CPU，每个CPU包括多个cores。总而言之，在一台现代计算机上，多个线程可能同时在执行（并行执行）。</p><p>通常</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发1-线程模型</title>
      <link href="/2021/06/01/java-bing-fa-1-xian-cheng-mo-xing/"/>
      <url>/2021/06/01/java-bing-fa-1-xian-cheng-mo-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="Java线程模型"><a href="#Java线程模型" class="headerlink" title="Java线程模型"></a>Java线程模型</h2><h3 id="什么是线程模型？为什么要有线程模型？"><a href="#什么是线程模型？为什么要有线程模型？" class="headerlink" title="什么是线程模型？为什么要有线程模型？"></a>什么是线程模型？为什么要有线程模型？</h3><blockquote><p>什么是线程模型</p></blockquote><p>Java字节码运行在JVM中，通过Java字节码创建的线程，我们叫它<code>JVM线程</code><br>JVM运行在各种操作系统上，当JVM想进行线程创建、线程回收的操作，需要进行操作系统级的系统调用，在操作系统中创建、回收真正的线程。这种“真正的线程”我们称为<code>操作系统线程</code><br>可以看出，<code>JVM线程</code>和<code>操作系统线程</code>存在着某种映射关系。这种映射关系（两种线程之间的规范和协议）叫做<code>线程模型</code></p><blockquote><p>为什么要有线程模型</p></blockquote><p>没有线程模型，难道你要手动调用操作系统的接口，直接对<code>操作系统线程</code>操作吗？<br>答案是：<code>抽象！</code><br>JVM为各种操作系统的原生线程进行了高级抽象，提供了统一的<code>JVM线程接口</code>给开发者使用，它不香吗？<br>之所以要学，是因为我们要知其然，还要知其所以然~</p><h3 id="线程模型分类"><a href="#线程模型分类" class="headerlink" title="线程模型分类"></a>线程模型分类</h3><ol><li>一对一<br>用户线程和内核线程一一对应<br>优点：简单、易用<br>缺点：内核创建线程是有上限的，进而影响用户线程的高并发。</li><li>多对一<br>多个用户线程对应一个内核线程<br>优点：扩展了用户线程的上限<br>缺点：一个用户线程进行系统调用并阻塞，会导致内核线程组内的所有线程都无法进行内核调用</li><li>多对多<br>缺点：复杂</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM基本架构</title>
      <link href="/2021/05/07/jvm-ji-ben-jia-gou/"/>
      <url>/2021/05/07/jvm-ji-ben-jia-gou/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-Virtual-Machine-JVM-基本架构"><a href="#Java-Virtual-Machine-JVM-基本架构" class="headerlink" title="Java Virtual Machine(JVM)基本架构"></a>Java Virtual Machine(JVM)基本架构</h1><p>JVM包含三个基本部分：</p><ol><li>Class Loader</li><li>Runtime Memory（Runtime Data Area）</li><li>Execution Engine</li></ol><p>下面分别介绍三个部分。</p><h2 id="Class-Loader"><a href="#Class-Loader" class="headerlink" title="Class Loader"></a>Class Loader</h2><p>在类加载过程中，分成三个阶段：加载、链接、初始化</p><h3 id="加载（Loading）"><a href="#加载（Loading）" class="headerlink" title="加载（Loading）"></a><strong>加载（Loading）</strong></h3><p>拿到一个类/接口的二进制表示（即字节码），Loading过程生成原本的类/接口，将class结构写入方法区。（未链接还不能使用）<br>Java中有三个内置的类加载器：</p><ul><li><code>Bootstrap Class Loader</code>: 这个是<code>root</code>类加载器，是<code>Extension Class Loader</code>的父类。<code>Bootstrap Class Loader</code>加载的是<code>Java</code>的标准包（<code>standard Java packages</code>），例如<code>java.lang</code>，<code>java.net</code>，<code>java.util</code>，<code>java.io</code>…<br>这些package在<code>rt.jar</code>文件中，还有一些核心库在<code>$JAVA_HOME/jre/lib</code>文件夹中。</li><li><code>Extension Class Loader</code>: 这个类加载器是<code>Bootstrap Class Loader</code>的子类，又是<code>Application Class Loader</code>的父类。<code>Extension Class Loader</code>加载的是位于<code>$JAVA_HOME/jre/lib/ext</code>文件夹中的，标准Java库的扩展。</li><li><code>Application Class Loader</code>: 最后一个类加载器<code>Application Class Loader</code>，是<code>Extension Class Loader</code>的子类，它加载<code>classpath</code>中的文件，而<code>classpath</code>默认设置为当前应用程序的文件夹。可以用命令行<code>-classpath</code>或<code>-cp</code>来修改<code>classpath</code>。<br>JVM使用<code>ClassLoader.loadClass()</code>方法来将类加载进内存。<br>JVM优先选择父类的类加载器（即：<code>Bootstrap Class Loader &gt; Extension Class Loader &gt; Application Class Loader</code>）当父类加载器找不到想要的类时，才会委托子类加载器去找。</li></ul><h3 id="链接（Linking）"><a href="#链接（Linking）" class="headerlink" title="链接（Linking）"></a><strong>链接（Linking）</strong></h3><p>当一个类被加载进内存，紧接着进行链接操作。链接操作有分为三个步骤。</p><h4 id="验证（Verification）"><a href="#验证（Verification）" class="headerlink" title="验证（Verification）"></a>验证（Verification）</h4><p>验证<code>.class</code>文件的结构正确性。通常指的是Java代码和虚拟机的Java版本是否匹配。</p><h4 id="准备（Preparation）"><a href="#准备（Preparation）" class="headerlink" title="准备（Preparation）"></a>准备（Preparation）</h4><p>在准备阶段，主要做了两件小事：</p><ol><li>JVM为类/接口中用<code>static</code>修饰的<strong>类变量分配内存</strong>，并用默认值初始化。<br>例如下面的代码：</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> enabled <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></code></pre><p>​    JVM在准备阶段会为类变量<code>enabled</code>分配内存，并用<code>boolean</code>类型的默认值<code>false</code>进行初始化操作。</p><ol start="2"><li><p>构造与该类相关联的<strong>方法表</strong>。</p><p>这个数据结构，便是 Java 虚拟机实现<code>动态绑定</code>的关键所在。下面我将以 invokevirtual 所使用的虚方法表（virtual method table，vtable）为例介绍方法表的用法。invokeinterface 所使用的接口方法表（interface method table，itable）稍微复杂些，但是原理其实是类似的。</p><p>方法表本质上是一个数组，每个数组元素指向一个当前类及其祖先类中<code>非私有</code>、<code>非final</code>的实例方法（<code>非static</code>）。</p><p>这些方法可能是具体的、可执行的方法，也可能是没有相应字节码的抽象方法。方法表满足两个特质：</p><ul><li><p>其一，子类方法表中包含<strong>父类方法表</strong>中的所有方法；（注意不是父类中的所有方法哦）</p><p>即：包含关系</p></li><li><p>其二，子类方法在方法表中的索引值，与它<strong>所重写的父类方法</strong>的索引值相同。</p><p>即：替换关系</p></li></ul><p>我们知道，方法调用指令中的符号引用会在执行之前解析成实际引用。</p><p>对于静态绑定的方法调用而言，实际引用将指向具体的目标方法。对于动态绑定的方法调用而言，实际引用则是方法表的索引值（实际上并不仅是索引值）。在执行过程中，Java 虚拟机将获取调用者的实际类型，并在该实际类型的虚方法表中，根据索引值获得目标方法。这个过程便是动态绑定。</p><p>让我们来看一个例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Passenger</span> <span class="token punctuation">{</span>  <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">passThroughImmigration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">ForeignerPassenger</span> <span class="token keyword">extends</span> <span class="token class-name">Passenger</span> <span class="token punctuation">{</span>   <span class="token annotation punctuation">@Override</span>   <span class="token keyword">void</span> <span class="token function">passThroughImmigration</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/* 进外国人通道 */</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">ChinesePassenger</span> <span class="token keyword">extends</span> <span class="token class-name">Passenger</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">void</span> <span class="token function">passThroughImmigration</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/* 进中国人通道 */</span> <span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">visitDutyFreeShops</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/* 逛免税店 */</span> <span class="token punctuation">}</span><span class="token punctuation">}</span>Passenger passenger <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token comment" spellcheck="true">// 多态，选择某个子类作为对象的实际类型</span>passenger<span class="token punctuation">.</span><span class="token function">passThroughImmigration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 根据调用者passenger的实际类型，并在该实际类型的虚方法表中，根据索引值获得目标方法</span></code></pre><img src="C:\Users\提高知识水平\AppData\Roaming\Typora\typora-user-images\image-20210813231035497.png" alt="image-20210813231035497" style="zoom: 80%;" /><p>在我们的例子中，Passenger 类的方法表包括两个方法：toString() 和 passThroughImmigration()，它们分别对应 0 号和 1 号。之所以方法表调换了 toString() 方法和 passThroughImmigration() 方法的位置，是因为 toString() 方法的索引值需要与 Object 类中同名方法的索引值一致。为了保持简洁，这里我就不考虑 Object 类中的其他方法。</p><p>ForeignerPassenger 的方法表同样有两行。其中，0 号方法指向继承而来的 Passenger 类的 toString() 方法。1 号方法则指向自己重写的 passThroughImmigration() 方法。</p><p>ChinesePassenger 的方法表则包括三个方法，除了继承而来的 Passenger 类的 toString() 方法，自己重写的 passThroughImmigration() 方法之外，还包括独有的 visitDutyFreeShops 方法。</p><pre class=" language-java"><code class="language-java">Passenger passenger <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>passenger<span class="token punctuation">.</span><span class="token function">passThroughImmigration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这里，JVM的工作可以想象为导航员。每当来了一个乘客需要出境，导航员会先问是中国人还是外国人（获取动态类型），然后翻出中国人 / 外国人对应的小册子（获取动态类型的方法表），小册子的第 1 页便写着应该如何办理手续（用 1 作为索引来查找方法表所对应的目标方法）。</p></li></ol><h4 id="解析（Resolution）"><a href="#解析（Resolution）" class="headerlink" title="解析（Resolution）"></a>解析（Resolution）</h4><p>在此阶段，将<code>符号引用</code>替换为在<code>运行时常量池</code>中存在的<code>直接引用</code>。</p><p>如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必触发这个类的链接以及初始化。）</p><p>此外，Java 虚拟机规范并没有要求在链接过程中完成解析。它仅规定了：如果某些字节码使用了符号引用，那么在执行这些字节码之前，需要完成对这些符号引用的解析。</p><h3 id="初始化（Initialization）"><a href="#初始化（Initialization）" class="headerlink" title="初始化（Initialization）"></a><strong>初始化（Initialization）</strong></h3><p>在 Java 代码中，如果要初始化一个静态字段，我们可以在声明时直接赋值，也可以在静态代码块中对其赋值。</p><ul><li><p>如果直接赋值的静态字段被 final 所修饰，并且它的类型是基本类型或字符串时，那么该字段便会被 Java 编译器标记成常量值（ConstantValue），其初始化直接由 Java 虚拟机完成。</p></li><li><p>除此之外的直接赋值操作，以及所有静态代码块中的代码，则会被 Java 编译器置于同一方法中，并把它命名为 &lt; clinit &gt;。随后执行类/接口的初始化方法（<code>&lt;clinit&gt;</code>）</p></li></ul><p>类加载的最后一步是初始化，便是为标记为常量值的字段赋值，以及执行 &lt; clinit &gt; 方法的过程。Java 虚拟机会通过加锁来确保类的 &lt; clinit &gt; 方法仅被执行一次，即在多线程情况下是安全的。<br>例如上面的例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> enabled <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></code></pre><p>类变量<code>enabled</code>在准备阶段被设置成<code>boolean</code>类型的默认值<code>false</code>，直到初始化阶段，才被标记成常量值，并由JVM直接赋予真正的值<code>true</code>。</p><p>只有当初始化完成之后，类才正式成为可执行的状态。那么，类的初始化何时会被触发呢？JVM 规范枚举了下述多种触发情况：</p><ol><li>当虚拟机启动时，初始化用户指定的主类；</li><li>当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类；</li><li>当遇到调用静态方法的指令时，初始化该静态方法所在的类；</li><li>当遇到访问静态字段的指令时，初始化该静态字段所在的类；</li><li>子类的初始化会触发父类的初始化；</li><li>如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；</li><li>使用反射 API 对某个类进行反射调用时，初始化这个类；</li><li>当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。</li></ol><p>下面代码是情况4的一个例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">LazyHolder</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> Singleton INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> LazyHolder<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这段代码是著名的单例延迟初始化例子:</p><p>只有当调用 Singleton.getInstance 时，程序才会访问 LazyHolder.INSTANCE，才会触发对 LazyHolder 的初始化（对应第 4 种情况），继而新建一个 Singleton 的实例。</p><p>由于类初始化是线程安全的，并且仅被执行一次，因此程序可以确保多线程环境下有且仅有一个 Singleton 实例。</p><h2 id="Runtime-Data-Area"><a href="#Runtime-Data-Area" class="headerlink" title="Runtime Data Area"></a>Runtime Data Area</h2><ol><li>方法区（Method Area）<br>存储所有类级别的数据，例如：运行时常量池、</li><li>堆区（Heap Area）</li><li>虚拟机栈（Stack Area）</li><li>本地方法栈（Native Method Stacks）</li><li>PC寄存器（Program Counter Registers）</li></ol><h2 id="Execution-Engine"><a href="#Execution-Engine" class="headerlink" title="Execution Engine"></a>Execution Engine</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论总结</title>
      <link href="/2020/07/05/gai-lu-lun-zong-jie/"/>
      <url>/2020/07/05/gai-lu-lun-zong-jie/</url>
      
        <content type="html"><![CDATA[<blockquote><h2 id="随机变量"><a href="#随机变量" class="headerlink" title="随机变量"></a>随机变量</h2></blockquote><h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><ol><li>随机现象：在一定的条件下，并不总是出现相同结果的现象称为随机现象。</li><li>随机试验：对在相同条件下可以重复的随机现象的观察、记录、试验称为随机试验。也有很多随机现象是不可重复的（例如：某场足球赛的胜负是无法重复的）。概率论与数理统计主要研究能大量重复的随机现象，但后者同样重要。</li><li>样本空间与样本点：随机现象的一切可能出现的基本结果组成的集合称为样本空间，记为 $ \Omega=\{\omega\} $，其中 $ \omega $ 为样本点，表示可能出现的基本结果。</li><li>随机变量：给定一个随机现象和它对应的样本空间，一个随机变量X给每个基本结果（样本点）赋予一个数值的值。Methematically,a random variable is a real-valued function of the experimental outcome.</li></ol><h3 id="二、易混淆概率对比"><a href="#二、易混淆概率对比" class="headerlink" title="二、易混淆概率对比"></a>二、易混淆概率对比</h3><h4 id="随机变量vs随机变量取值"><a href="#随机变量vs随机变量取值" class="headerlink" title="随机变量vs随机变量取值"></a>随机变量vs随机变量取值</h4><h4 id="PMF、PDF、CDF"><a href="#PMF、PDF、CDF" class="headerlink" title="PMF、PDF、CDF"></a>PMF、PDF、CDF</h4><ol><li>概念解释</li></ol><ul><li>PMF（probability mass function）概率质量函数：在概率论中，概率质量函数是<code>离散随机变量</code>在各特定取值上的概率。</li><li>PDF（probability density function）概率密度函数：<code>连续型随机变量</code>的概率密度函数（在不至于混淆时可以简称为密度函数）是一个描述这个随机变量的输出值，在某个确定的取值点附近的可能性的函数。</li><li>CDF（cumulative distribution function）累积分布函数：又叫分布函数，是<code>PDF</code>的积分/<code>PMF</code>的累加，能完整描述一个实随机变量X的概率分布。</li></ul><ol start="2"><li>数学表示<br>1) PMF<br>$$ p_X(x)=P(X=x) $$<br>2) PDF<br>$$ P(a \leqslant X \leqslant b)=\int_{a}^{b}f_X(x)dx $$<br>3) CDF</li></ol><ul><li>对于离散型随机变量</li><li>对于连续型随机变量<br>$$ F_X(x)=P(X \leqslant x)=\int_{-\infty }^{x}f_X(x)dx $$</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概率论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建博客基本用法</title>
      <link href="/2020/05/08/hexo-da-jian-bo-ke-ji-ben-yong-fa/"/>
      <url>/2020/05/08/hexo-da-jian-bo-ke-ji-ben-yong-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="发布新博客"><a href="#发布新博客" class="headerlink" title="发布新博客"></a>发布新博客</h2><ol><li>创建新博客<pre class=" language-bash"><code class="language-bash">hexo new post <span class="token string">"新的博客名"</span></code></pre>会在<code>C:\code\git\hhhOscar.github.io\source\_posts</code>目录下新创建一个<code>资源（图片）文件夹</code>和一个<code>.md</code>文件</li><li>发布博客<pre class=" language-bash"><code class="language-bash">hexo g     // 生成静态网页hexo s     // 本地预览效果hexo d     // 上传到Github上</code></pre></li></ol><h2 id="文章-Front-matter-介绍"><a href="#文章-Front-matter-介绍" class="headerlink" title="文章 Front-matter 介绍"></a>文章 Front-matter 介绍</h2><h3 id="Front-matter-选项详解"><a href="#Front-matter-选项详解" class="headerlink" title="Front-matter 选项详解"></a>Front-matter 选项详解</h3><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>cover</td><td><code>false</code></td><td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>keywords</td><td>文章标题</td><td>文章关键字，SEO 时需要</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><h3 id="最全示例"><a href="#最全示例" class="headerlink" title="最全示例"></a>最全示例</h3><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">title</span><span class="token punctuation">:</span> hexo搭建博客基本用法<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2020-05-08 13:10:25</span><span class="token key atrule">author</span><span class="token punctuation">:</span> RockZ<span class="token key atrule">img</span><span class="token punctuation">:</span> /source/images/xxx.jpg<span class="token key atrule">top</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">cover</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">coverImg</span><span class="token punctuation">:</span> /images/1.jpg<span class="token key atrule">password</span><span class="token punctuation">:</span> 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92<span class="token key atrule">toc</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">mathjax</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">summary</span><span class="token punctuation">:</span> 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要<span class="token key atrule">categories</span><span class="token punctuation">:</span> Markdown<span class="token key atrule">tags</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> Hexo  <span class="token punctuation">-</span> Github</code></pre><h2 id="代码块怎么写"><a href="#代码块怎么写" class="headerlink" title="代码块怎么写"></a>代码块怎么写</h2><h3 id="css实例"><a href="#css实例" class="headerlink" title="css实例"></a>css实例</h3><pre class=" language-css"><code class="language-css"><span class="token selector">pre </span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* padding: 1.5rem !important; */</span>    <span class="token property">padding</span><span class="token punctuation">:</span> <span class="token number">1.5</span>rem <span class="token number">1.5</span>rem <span class="token number">1.5</span>rem <span class="token number">3.3</span>rem <span class="token important">!important</span><span class="token punctuation">;</span>    <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">1</span>rem <span class="token number">0</span> <span class="token important">!important</span><span class="token punctuation">;</span>    <span class="token property">background</span><span class="token punctuation">:</span> <span class="token hexcode">#272822</span><span class="token punctuation">;</span>    <span class="token property">overflow</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>    <span class="token property">border-radius</span><span class="token punctuation">:</span> <span class="token number">0.35</span>rem<span class="token punctuation">;</span>    <span class="token property">tab-size</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">code </span><span class="token punctuation">{</span>    <span class="token property">padding</span><span class="token punctuation">:</span> <span class="token number">1</span>px <span class="token number">5</span>px<span class="token punctuation">;</span>    <span class="token property">font-family</span><span class="token punctuation">:</span> Inconsolata, Monaco, Consolas, <span class="token string">'Courier New'</span>, Courier, monospace<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* font-size: 0.91rem; */</span>    <span class="token property">color</span><span class="token punctuation">:</span> <span class="token hexcode">#e96900</span><span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token hexcode">#f8f8f8</span><span class="token punctuation">;</span>    <span class="token property">border-radius</span><span class="token punctuation">:</span> <span class="token number">2</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="如何在md文件中书写"><a href="#如何在md文件中书写" class="headerlink" title="如何在md文件中书写"></a>如何在md文件中书写</h3><pre><code>```cssyour code here```</code></pre><h3 id="支持语言"><a href="#支持语言" class="headerlink" title="支持语言"></a>支持语言</h3><p><a href="https://prismjs.com/#languages-list" target="_blank" rel="noopener">官方文档</a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank" rel="noopener">github上的hexo主题</a><br><a href="https://godweiyang.com/2018/04/13/hexo-blog/" target="_blank" rel="noopener">超详细Hexo+Github博客搭建小白教程</a><br><a href="https://segmentfault.com/a/1190000007261752?utm_source=sf-related" target="_blank" rel="noopener">Hexo下mathjax的转义问题</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/05/02/hello-world/"/>
      <url>/2020/05/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
