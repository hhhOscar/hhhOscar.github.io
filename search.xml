<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring源码学习</title>
      <link href="/2021/10/09/spring-yuan-ma-xue-xi/"/>
      <url>/2021/10/09/spring-yuan-ma-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring源码学习"><a href="#Spring源码学习" class="headerlink" title="Spring源码学习"></a>Spring源码学习</h1><p>Spring是个很牛逼的公司，他做了一系列的相关的项目</p><p><img src=".%5CSpring%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%5Cimage-20211009210524608.png" alt="image-20211009210524608"></p><p>本文讲解最重要、最基础的Spring Framework这个项目。这也是其他项目的基础。</p><h2 id="前情回顾"><a href="#前情回顾" class="headerlink" title="前情回顾"></a>前情回顾</h2><h3 id="Spring-bean"><a href="#Spring-bean" class="headerlink" title="Spring bean"></a>Spring bean</h3><p>Spring bean是啥？</p><ol><li>就是一个Java对象</li><li>这个对象由Spring容器管理。</li><li><code>可能</code>有一套完整的<code>生命周期</code>。</li></ol><h3 id="IOC-DI"><a href="#IOC-DI" class="headerlink" title="IOC == DI"></a>IOC == DI</h3><p>Spring Framework（以下简称Spring）中最重要的就是 <code>Inversion of Control (IoC)容器</code>。<code>IOC</code>也被叫做<code>dependency injection (DI)</code>。定义如下：</p><blockquote><p>It is a process whereby objects define their dependencies (that is, the other objects they work with) only through constructor arguments, arguments to a factory method, or properties that are set on the object instance after it is constructed or returned from a factory method. The container then injects those dependencies when it creates the bean. This process is fundamentally the inverse (hence the name, Inversion of Control) of the bean itself controlling the instantiation or location of its dependencies by using direct construction of classes or a mechanism such as the Service Locator pattern.</p></blockquote><p>翻译一下：</p><p><code>IOC</code>就是对象通过<code>构造函数参数</code>、或<code>工厂方法参数</code>、或<code>属性值</code>来<code>定义</code>它自身的<code>依赖</code>（即定义在这个对象中的其他对象）。然后这个对象通过<code>构造函数</code>或者<code>工厂方法</code> 来<code>实例化</code>之后，由容器负责，将上面定义的依赖注入到对象中。</p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池源码分析</title>
      <link href="/2021/09/29/xian-cheng-chi-yuan-ma-fen-xi/"/>
      <url>/2021/09/29/xian-cheng-chi-yuan-ma-fen-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="线程池源码分析"><a href="#线程池源码分析" class="headerlink" title="线程池源码分析"></a>线程池源码分析</h1><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="execute-Runnable-command-方法"><a href="#execute-Runnable-command-方法" class="headerlink" title="execute(Runnable command)方法"></a>execute(Runnable command)方法</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*         * 过程分为3步走:         *         * 1. 如果线程池中的线程数 &lt; corePoolSize：         * 尝试用给定的command开启一个新线程，并将command作为它的firstTask         * addWorkder方法会检查runState和workerCount，在下面两种情况会失败，并return false：                  1）存在并发的情况，在addWorker中再次检查线程数，发现 >= corePoolSize                 2）其他线程修改了线程池状态，导致线程池不再RUNNING         * return false之后，要重新获取ctl的值         *         * 2.如果线程池还在Running，说明失败的原因是线程数 >= corePoolSize         * 那么尝试把任务加到workQueue中，如果成功入队，还需要double-check：                  1） 如果在入队的过程中（需要一段时间），其他线程把线程池的状态改变了：                     我们尝试把任务从队列中移除，如果移除成功，直接reject(command)                  2） 如果入队后线程池还在running，或者移除失败，那么任务还是要处理的                      因此如果在入队的过程中（需要一段时间），线程池中的线程数量变成0（可能因为                 allowCoreThreadTimeOut=true，也可能因为使用newCachedThreadPool）：                 我们就要开启一个新线程去处理队列中的任务。         *         * 3.如果进入这个分支，只有两种情况：                 1）线程池不是RUNNING                 2）线程数超过核心线程数且workQueue中数据已满。         * 第二种情况还可以抢救一下，执行添加worker操作。         * 如果还失败，说明达到maximumPoolSize。shutdown了或者full了，直接reject(command)         */</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> recheck <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isRunning</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">remove</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">addWorker</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="addWaiter-Runnable-firstTask-boolean-core-方法"><a href="#addWaiter-Runnable-firstTask-boolean-core-方法" class="headerlink" title="addWaiter(Runnable firstTask, boolean core)方法"></a>addWaiter(Runnable firstTask, boolean core)方法</h3><p><code>execute()</code>这个提交任务的方法 多次用到<code>addWorker</code>方法，这个方法接收任务后将任务添加到<code>Worker</code>中。</p><p>所以我们先来看<code>Worker</code>是个啥</p><p><code>Worker</code>是ThreadPoolExecutor中的<code>内部类</code>，继承自<code>AQS</code>且实现了<code>Runnable</code>接口。 类中包含<code>Thread thread</code>，它是worker内部封装的工作线程，还有<code>firstTask</code>属性，它是一个可执行的Runnable对象。</p><p>在Worker的构造函数中，使用线程工厂创建了一个线程，当thread启动的时候，会以worker.run()为入口启动线程，这里会直接调用到runWorker()中<code>（见代码注释19行）</code>。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Worker</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** Thread this worker is running in.  Null if factory fails. */</span>    <span class="token keyword">final</span> Thread thread<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** Initial task to run.  Possibly null. */</span>    Runnable firstTask<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** Per-thread task counter */</span>    <span class="token keyword">volatile</span> <span class="token keyword">long</span> completedTasks<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * Creates with given first task and thread from ThreadFactory.     * @param firstTask the first task (null if none)     */</span>    <span class="token function">Worker</span><span class="token punctuation">(</span>Runnable firstTask<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setState</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// inhibit interrupts until runWorker</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>firstTask <span class="token operator">=</span> firstTask<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 注意这一行！！！ Worker实例作为Runnable对象传进了Worker中的thread</span>        <span class="token comment" spellcheck="true">// 因此线程执行，实际上会调用Worker的run方法，进而调用runWorker(this)</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token function">getThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newThread</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/** Delegates main run loop to outer runWorker  */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">runWorker</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// this指向内部类Worker的实例</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Lock methods</span>    <span class="token comment" spellcheck="true">//</span>    <span class="token comment" spellcheck="true">// The value 0 represents the unlocked state.</span>    <span class="token comment" spellcheck="true">// The value 1 represents the locked state.</span>    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> unused<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> unused<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">interruptIfStarted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread t<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>t <span class="token operator">=</span> thread<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>t<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                t<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SecurityException</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>先看addWorker流程：</p><p><img src="C:%5Ccode%5Cgit%5ChhhOscar.github.io%5Csource_posts%5C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%5CaddWorker.png" alt=""></p><p>再看<code>addWorker</code>源码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">addWorker</span><span class="token punctuation">(</span>Runnable firstTask<span class="token punctuation">,</span> <span class="token keyword">boolean</span> core<span class="token punctuation">)</span> <span class="token punctuation">{</span>    retry<span class="token operator">:</span>  <span class="token comment" spellcheck="true">// 标记下一行是一个循环方法，break retry、continue retry会跳到这一层循环处理</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/**        private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;        private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;        private static final int STOP       =  1 &lt;&lt; COUNT_BITS;        private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;        private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;        */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">>=</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>rs <span class="token operator">==</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> firstTask <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>wc <span class="token operator">>=</span> CAPACITY <span class="token operator">||</span> wc <span class="token operator">>=</span> <span class="token punctuation">(</span>core <span class="token operator">?</span> corePoolSize <span class="token operator">:</span> maximumPoolSize<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndIncrementWorkerCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">break</span> retry<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 跳出外层循环</span>            c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> rs<span class="token punctuation">)</span>                <span class="token keyword">continue</span> retry<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 从外层循环continue</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">boolean</span> workerStarted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> workerAdded <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    Worker w <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        w <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>firstTask<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> Thread t <span class="token operator">=</span> w<span class="token punctuation">.</span>thread<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>            mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">&lt;</span> SHUTDOWN <span class="token operator">||</span>                    <span class="token punctuation">(</span>rs <span class="token operator">==</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> firstTask <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalThreadStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    workers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">int</span> s <span class="token operator">=</span> workers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> largestPoolSize<span class="token punctuation">)</span>                        largestPoolSize <span class="token operator">=</span> s<span class="token punctuation">;</span>                    workerAdded <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>workerAdded<span class="token punctuation">)</span> <span class="token punctuation">{</span>                t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                workerStarted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>workerStarted<span class="token punctuation">)</span>            <span class="token function">addWorkerFailed</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> workerStarted<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ol><li><p>两层<code>for (;;)</code>循环</p><ul><li><p>外层循环：主要是判断线程池的状态，如果状态不合法就直接返回<code>false</code>.</p><p>只有两种情况属于合法状态，继续执行下面的内循环：</p><ol><li><code>rs &lt; SHUTDOWN</code>：即<code>RUNNING</code>状态</li><li><code>rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; !workQueue.isEmpty()</code>：即<code>SHUTDOWN</code>状态时，队列中还有未处理的任务，且提交的任务为空。这种情况是允许创建线程继续处理阻塞队列的任务。</li></ol></li><li><p>内层循环：</p><p>首先还是判断状态是否合法：判断线程池<code>workCount</code>数量是否大于可创建的最大值；或者想创建核心线程的时候是否超过了核心线程数/想创建临时工线程时是否超过了最大线程数。如果是则直接<code>return false</code>，<code>addWorker()</code>操作失败。</p><p>接着通过<code>CAS</code>操作更新<code>workCount</code>数量+1，如果更新成功则直接跳出外层循环，往线程池中中添加<code>worker</code>，这个所谓的线程池就是一个HashSet数组。</p><p>如果<code>CAS</code>失败，说明此时有竞争，会重新获取<code>ctl</code>的值，判断竞争失败的原因是其他线程修改<code>workCount</code>数量还是修改线程池状态导致的：</p><ul><li>如果线程池状态未发生改变，就继续内层循环尝试<code>CAS</code>增加<code>workCount</code>数量</li><li>如果线程池状态发生改变，只好重新走一遍外层循环，检查状态是否合法。</li></ul></li></ul></li><li><p>接着看循环结束后逻辑：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">boolean</span> workerStarted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">boolean</span> workerAdded <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>Worker w <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    w <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>firstTask<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> Thread t <span class="token operator">=</span> w<span class="token punctuation">.</span>thread<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>        mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">&lt;</span> SHUTDOWN <span class="token operator">||</span> <span class="token punctuation">(</span>rs <span class="token operator">==</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> firstTask <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalThreadStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                workers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> s <span class="token operator">=</span> workers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> largestPoolSize<span class="token punctuation">)</span>                    largestPoolSize <span class="token operator">=</span> s<span class="token punctuation">;</span>                workerAdded <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>workerAdded<span class="token punctuation">)</span> <span class="token punctuation">{</span>            t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            workerStarted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>workerStarted<span class="token punctuation">)</span>        <span class="token function">addWorkerFailed</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>一段一段來看：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">boolean</span> workerStarted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">boolean</span> workerAdded <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></code></pre><p>这里<code>workerStarted</code>代表<code>worker</code>是否已经启动，<code>workerAdded</code>代表创建的<code>worker</code>是否添加到池子中，这里所谓的池子就是全局定义的一个<code>workers</code>对象的<code>HashSet</code>集合：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> HashSet<span class="token operator">&lt;</span>Worker<span class="token operator">></span> workers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span>Worker<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ol><pre class=" language-java"><code class="language-java">   w <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>firstTask<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">final</span> Thread t <span class="token operator">=</span> w<span class="token punctuation">.</span>thread<span class="token punctuation">;</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>   <span class="token punctuation">}</span></code></pre><p>   接着根据传递的<code>firstTask</code>来构建一个<code>worker</code>，在<code>Worker类</code>的构造方法中也会通过<code>ThreadFactory</code>创建一个线程，这里判断<code>t != null</code>是因为用户可以自定义<code>ThreadFactory</code>，如果这里用户不是创建线程而是直接返回null则会出现一些问题，所以需要判断一下。</p><pre class=" language-java"><code class="language-java">   <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>   mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>   在往池子中添加<code>Worker</code>的时候，是需要先加锁的，因为针对全局的<code>workers</code>操作并不是线程安全的。</p><pre class=" language-java"><code class="language-java">   <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">&lt;</span> SHUTDOWN <span class="token operator">||</span> <span class="token punctuation">(</span>rs <span class="token operator">==</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> firstTask <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>           <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalThreadStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>   <span class="token punctuation">}</span></code></pre><p>   下面再次判断<code>addWaiter</code>状态是否合法。<code>rs</code>代表当前线程池的状态，如果<code>rs &lt; SHUTDOWN</code>代表线程池状态是RUNNING状态，此时可以<code>addWaiter</code>。<br>   如果是<code>SHUTDOWN</code>状态，需要满足<code>firstTask == null</code>才可以继续操作。因为在<code>SHUTDOWN</code>状态时不会再添加新的任务，但还是可以继续处理<code>workQueue</code>中的任务。</p><p>   <code>t.isAlive()</code> 当线程<code>start</code>后，线程<code>isAlive</code>会返回<code>true</code>，这里还是防止自定义的<code>ThreadFactory</code>创建线程返回给外部之前，将线程<code>start</code>了，由此可见<code>Doug lea</code>考虑问题真的很全面。</p><pre class=" language-java"><code class="language-java">   workers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> s <span class="token operator">=</span> workers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> largestPoolSize<span class="token punctuation">)</span>       largestPoolSize <span class="token operator">=</span> s<span class="token punctuation">;</span>   workerAdded <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></code></pre><p>   接着将创建的<code>Worker</code>添加到<code>workers</code>集合中，更新<code>largestPoolSize</code>值，这个属性是线程池生命周期内线程数最大值，一般是做统计数据用的。 最后修改<code>workerAdded = true</code>，代表当前提交的任务所创建的<code>Worker</code>已经添加到池子中了。</p><pre class=" language-java"><code class="language-java">   <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>   mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">try</span> <span class="token punctuation">{</span>       <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">&lt;</span> SHUTDOWN <span class="token operator">||</span> <span class="token punctuation">(</span>rs <span class="token operator">==</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> firstTask <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>               <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalThreadStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           workers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token keyword">int</span> s <span class="token operator">=</span> workers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> largestPoolSize<span class="token punctuation">)</span>               largestPoolSize <span class="token operator">=</span> s<span class="token punctuation">;</span>           workerAdded <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>   <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>       mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>workerAdded<span class="token punctuation">)</span> <span class="token punctuation">{</span>       t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       workerStarted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span></code></pre><p>   <code>worker</code>添加成功后，会调用线程的<code>start()</code>方法启动线程（19行），因为<code>Worker</code>中重写了<code>run()</code>方法，最后会执行<code>Worker.run()</code>。最后设置<code>workerStarted = true</code>后释放全局锁。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mini Tomcat Server</title>
      <link href="/2021/09/26/mini-tomcat-server/"/>
      <url>/2021/09/26/mini-tomcat-server/</url>
      
        <content type="html"><![CDATA[<h1 id="手写一个Mini-Tomcat服务器"><a href="#手写一个Mini-Tomcat服务器" class="headerlink" title="手写一个Mini Tomcat服务器"></a>手写一个Mini Tomcat服务器</h1><h2 id="Tomcat整体架构-amp-处理请求流程"><a href="#Tomcat整体架构-amp-处理请求流程" class="headerlink" title="Tomcat整体架构 &amp; 处理请求流程"></a>Tomcat整体架构 &amp; 处理请求流程</h2><h3 id="架构分析"><a href="#架构分析" class="headerlink" title="架构分析"></a>架构分析</h3><ul><li>Tomcat是什么？</li></ul><p>Tomcat是一个Servlet容器。</p><p>一个Servlet应用程序，可以打包成jar包或war包。这两个有什么区别呢？</p><p>war包丢到Tomcat的webapps目录下，启动Tomcat后，就可以通过：</p><pre><code>http://localhost:8080/Servlet-name/url-path</code></pre><p>的方式访问服务了。</p><p>而一个jar包丢到Tomcat的webapps目录下，Tomcat根本不知道这是个web应用还是一个其他web应用的依赖包，所以Tomcat实现上只处理了以.war结尾的压缩包。因此jar包自然就运行不了了。</p><p>因此我们从语义上可以对这两种打包的格式做出区分：看到war包我们就当成web应用处理；看到jar包我们就按照依赖包处理。</p><p>除了把war包放到webapps目录下、把war包解压出来的文件夹放到webapps目录下，还可以通过修改Tomcat的<code>apache-tomcat-8.0.11-src\conf\server.xml</code>文件中的<code>&lt;Context&gt;</code>节点来指定服务器某个文件路径下的web程序，如：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Host</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>localhost<span class="token punctuation">"</span></span>  <span class="token attr-name">appBase</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>webapps<span class="token punctuation">"</span></span>      <span class="token attr-name">unpackWARs</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">autoDeploy</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 添加这一行，就添加了一个可以访问的web应用>    &lt;Context path="/Hello" docBase="C:/Users\提高知识水平/Desktop/ServletDemo" />    &lt;!-- SingleSignOn valve, share authentication between web applications             Documentation at: /docs/config/valve.html --></span>    <span class="token comment" spellcheck="true">&lt;!--        &lt;Valve className="org.apache.catalina.authenticator.SingleSignOn" />        --></span>    <span class="token comment" spellcheck="true">&lt;!-- Access log processes all example.             Documentation at: /docs/config/valve.html             Note: The pattern used is equivalent to using pattern="common" --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Valve</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.apache.catalina.valves.AccessLogValve<span class="token punctuation">"</span></span> <span class="token attr-name">directory</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>logs<span class="token punctuation">"</span></span>           <span class="token attr-name">prefix</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>localhost_access_log<span class="token punctuation">"</span></span> <span class="token attr-name">suffix</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>.txt<span class="token punctuation">"</span></span>           <span class="token attr-name">pattern</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>%h %l %u %t &amp;quot;%r&amp;quot; %s %b<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Host</span><span class="token punctuation">></span></span></code></pre><p>我们不难猜测：一个Context代表了一个Web程序。那其他标签是不是也相应的对应了Tomcat中的某些组件呢？</p><p>Tomcat的完整架构图如下：</p><p><img src="%5CMini-Tomcat-Server%5Ctomcat-architecture.png" alt=""></p><p>从<code>server.xml</code>文件中，可以看出它们符合上面的层次结构：</p><pre class=" language-xml"><code class="language-xml">&lt;? xml version='1.0' encoding='utf-8'? ><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Server</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Listener</span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>GlobalNamingResources</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Resource</span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>GlobalNamingResources</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Service</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Executor</span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Connector</span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Engine</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Cluster</span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Realm</span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Host</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Context</span><span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Valve</span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Host</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Engine</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Service</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Server</span><span class="token punctuation">></span></span></code></pre><p>简单介绍下这些组件是干嘛的。</p><h4 id="组件介绍"><a href="#组件介绍" class="headerlink" title="组件介绍"></a>组件介绍</h4><ol><li><p>Server组件</p><p>Server是最顶级的组件，它代表Tomcat的运行实例，在一个JVM中只会包含一个Server。在Server的整个生命周期中，不同阶段会有不同的事情要完成。为了方便扩展，它引入了监听器方式，所以它也包含了Listener组件。另外，为了方便在Tomcat中集成JNDI，引入了GlobalNamingResources组件。同时，还包含了Service核心组件。</p><p>Server组件在Tomcat中的实现类是StandardServer，除了表示Service的一个对象数组外，主要是一些关于Tomcat的属性，比如port，address等。</p></li><li><p>Service组件</p><p>Service组件是连接器（Connector）和容器（Container）的组合。一个Tomcat实例中可以有多个Service组件，它们彼此独立。StandardService是Service组件的实现类。如果上面的Server组件代表Tomcat服务器实例的话，那么Service组件就是这个服务器上面对外提供的一个个具体的服务。这个服务监听这不同的端口，你要访问哪些服务必须指定这些服务对应的端口。这样一类比的话就和具体的硬件服务器很像。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StandardService</span> <span class="token keyword">extends</span> <span class="token class-name">LifecycleMBeanBase</span> <span class="token keyword">implements</span> <span class="token class-name">Service</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Server server <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">protected</span> Connector connectors<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Connector</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Engine engine <span class="token operator">=</span>null<span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token keyword">final</span> Mapper mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Mapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>server表示其所属Server，Engine作为处理该service中Connector的容器。Mapper可以看作是映射器，要来处理请求地址到处理该请求的容器及Servlet的映射。</p><p><img src="%5CMini-Tomcat-Server%5CService.png" alt=""></p><p>另外，service组件还有一个Executor组件，这个线程池组件可以被多个连接器组件共享，而不是每个连接器组件都使用自己的线程池。</p></li><li><p>Connector组件</p><p>表示Tomcat中的连接器，其主要作用是监听并转化Socket请求，并交由Container处理。其实就是对不同协议及协议处理器进行的封装。下面是我们需要关注的几个属性域：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Connector</span> <span class="token keyword">extends</span> <span class="token class-name">LifecycleMBeanBase</span><span class="token punctuation">{</span>    <span class="token keyword">protected</span> Service service <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token keyword">final</span> ProtocolHandler protocolHandler<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>不同的协议会对应不同的Connector，目前Tomcat支持HTTP（HTTPS）和AJP两种协议的Connector。另外同一种协议的内部也会根据网络IO方式的不同分为阻塞IO和非阻塞IO。下面以HTTP协议为列子简单介绍：</p><ul><li><p>BIO模式</p><p><img src="%5CMini-Tomcat-Server%5CConnector-bio.png" alt=""></p><ul><li>Http11Protocol组件，是HTTP协议1.1版本的抽象，它包含接收客户端连接、接收客户端消息报文、报文解析处理、对客户端响应等整个过程。它主要包含JIoEndpoint组件和Http11Processor组件。启动时，JIoEndpoint组件内部的Acceptor组件将启动某个端口的监听，一个请求到来后将被扔进线程池Executor，线程池进行任务处理，处理过程中将通过Http11Processor组件对HTTP协议解析并传递到Engine容器继续理。</li><li>Mapper组件，客户端请求的路由导航组件，通过它能对一个完整的请求地址进行路由，通俗地说，就是它能通过请求地址找到对应的Servlet。</li><li>CoyoteAdaptor组件，一个将Connector和Container适配起来的适配器。</li></ul></li><li><p>NIO模式</p><p><img src="%5CMini-Tomcat-Server%5CConnector-nio.png" alt=""></p><p>如上图所示，在非阻塞I/O方式下，Connector的结构类似阻塞模式，Http11Protocol组件改成Http11NioProtocol组件，JIoEndpoint组件改成NioEndpoint, Http11Processor组件改成Http11NioProcessor组件，这些类似的组件的功能也都类似。唯独多了一个Poller组件，它的职责是在非阻塞I/O方式下轮询多个客户端连接，不断检测、处理各种事件，例如不断检测各个连接是否有可读，对于可读的客户端连接则尝试进行读取并解析消息报文。</p></li></ul></li><li><p>Engine组件</p><p><code>Tomcat内部有4个级别的容器，分别是Engine、Host、Context和Wrapper</code>。Engine代表全局Servlet引擎，<strong>每个Service组件只能包含一个Engine容器组件，但Engine组件可以包含若干Host容器组件。</strong>除了Host之外，它还包含如下组件。</p><ul><li>Listener组件：可以在Tomcat生命周期中完成某些Engine容器相关工作的监听器。</li><li>AccessLog组件：客户端的访问日志，所有客户端访问都会被记录。</li><li>Cluster组件：它提供集群功能，可以将Engine容器需要共享的数据同步到集群中的其他Tomcat实例上。</li><li>Pipeline组件：Engine容器对请求进行处理的管道。</li><li>Realm组件：提供了Engine容器级别的用户-密码-权限的数据对象。</li></ul></li><li><p>Host组件</p><p>Tomcat中Host组件代表虚拟主机，这些虚拟主机可以存放多个Web应用的抽象（Context容器）。除了Context组件之外，它还包含如下组件。</p><ul><li>Listener组件：可以在Tomcat生命周期中完成某些Host容器相关工作的监听器。</li><li>AccessLog组件：客户端的访问日志，对该虚拟主机上所有Web应用的访问都会被记录。</li><li>Cluster组件：它提供集群功能，可以将Host容器需要共享的数据同步到集群中的其他Tomcat实例 上。</li><li>Pipeline组件：Host容器对请求进行处理的管道。</li><li>Realm组件：提供了Host容器级别的用户-密码-权限的数据对象，配合资源认证模块使用。</li></ul></li><li><p>Context组件</p><p>Context组件是Web应用的抽象，我们开发的Web应用部署到Tomcat后运行时就会转化成Context对象。它包含了各种静态资源、若干Servlet（Wrapper容器）以及各种其他动态资源。它主要包括如下组件。</p><ul><li>Listener组件：可以在Tomcat生命周期中完成某些Context容器相关工作的监听器。</li><li>Filter组件：过滤器组件，提供统一的业务逻辑处理。</li><li>AccessLog组件：客户端的访问日志，对该Web应用的访问都会被记录。</li><li>Pipeline组件：Context容器对请求进行处理的管道。</li><li>Realm组件：提供了Context容器级别的用户-密码-权限的数据对象，配合资源认证模块使用。</li><li>Loader组件：Web应用加载器，用于加载Web应用的资源，它要保证不同Web应用之间的资源隔离</li><li>Manager组件：会话管理器，用于管理对应Web容器的会话，包括维护会话的生成、更新和销毁。</li><li>NamingResource组件：命名资源，它负责将Tomcat配置文件的server.xml和Web应用的context.xml资源和属性映射到内存中。</li><li>Mapper组件：Servlet映射器，它属于Context内部的路由映射器，只负责该Context容器的路由导航.</li><li>Wrapper组件：Context的子容器。</li></ul></li><li><p>Wrapper组件</p><p>Wrapper容器是Tomcat中4个级别的容器中最小的，与之相对应的是Servlet，一个Wrapper对应一个Servlet。它包含如下组件。</p><ul><li>Servlet组件：Servlet即Web应用开发常用的Servlet，我们会在Servlet中编写好请求的逻辑处理。</li><li>ServletPool组件：Servlet对象池，当Web应用的Servlet实现了SingleThreadModel接口时则会在Wrapper中产生一个Servlet对象池。线程执行时，需先从对象池中获取到一个Servlet对象，ServletPool组件能保证Servlet对象的线程安全。</li><li>Pipeline组件：Wrapper容器对请求进行处理的管道。</li></ul></li></ol><p>从接口的继承关系来看，Engine、Host、Context、Wrapper确实都继承了Container接口，代表他们是不同层次的Servlet容器。</p><p><img src="%5CMini-Tomcat-Server%5Ccore-interfaces.png" alt="image-20210926165306198"></p><h3 id="处理请求流程"><a href="#处理请求流程" class="headerlink" title="处理请求流程"></a>处理请求流程</h3><p><img src="%5CMini-Tomcat-Server%5Creq-process.png" alt="image-20210926222500809"></p><h2 id="Tomcat中自定义类加载器的使用和源码实现"><a href="#Tomcat中自定义类加载器的使用和源码实现" class="headerlink" title="Tomcat中自定义类加载器的使用和源码实现"></a>Tomcat中自定义类加载器的使用和源码实现</h2><h2 id="Tomcat请求处理详解与源码实现"><a href="#Tomcat请求处理详解与源码实现" class="headerlink" title="Tomcat请求处理详解与源码实现"></a>Tomcat请求处理详解与源码实现</h2><h2 id="Tomcat启动过程"><a href="#Tomcat启动过程" class="headerlink" title="Tomcat启动过程"></a>Tomcat启动过程</h2><h2 id="Tomcat中Session功能的实现"><a href="#Tomcat中Session功能的实现" class="headerlink" title="Tomcat中Session功能的实现"></a>Tomcat中Session功能的实现</h2><h2 id="Tomcat中JSP的实现"><a href="#Tomcat中JSP的实现" class="headerlink" title="Tomcat中JSP的实现"></a>Tomcat中JSP的实现</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
            <tag> 项目 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程问题入口</title>
      <link href="/2021/09/24/java-duo-xian-cheng-wen-ti-ru-kou/"/>
      <url>/2021/09/24/java-duo-xian-cheng-wen-ti-ru-kou/</url>
      
        <content type="html"><![CDATA[<blockquote><p>说明：本文是多线程问题的大纲。具体细节通过链接查看。</p></blockquote><h3 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h3><h3 id="创建线程的三种方式的对比？"><a href="#创建线程的三种方式的对比？" class="headerlink" title="创建线程的三种方式的对比？"></a>创建线程的三种方式的对比？</h3><ol><li>通过实现Thread类的方法创建线程</li><li>通过实现Runnable接口创建线程</li><li>通过实现Callable接口创建线程</li><li>通过线程池创建线程，本质是2、3</li></ol><p>区别：</p><ol><li>Callable接口重写call()方法，Runnable重写的方法是run()。</li><li>Callable的任务执行后可返回值，因此需要指定返回值的类型；而Runnable的任务没有返回值。</li><li>Call方法可以抛出异常，run方法不可以。</li><li>运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。</li></ol><h3 id="什么是线程死锁-如何避免死锁"><a href="#什么是线程死锁-如何避免死锁" class="headerlink" title="什么是线程死锁?如何避免死锁?"></a>什么是线程死锁?如何避免死锁?</h3><ul><li><p>什么是死锁：</p><p>多线程环境下，多个线程可能竞争一定数量的资源。某个线程申请资源，如果此时资源不可用，那么该线程进入等待状态。如果申请的资源被其他资源所占有，那么该等待线程可能再也无法改变其等待状态。这种情况称为死锁。</p></li><li><p>死锁的必要条件</p><p>如果以下4个条件同时满足，就会引起死锁：</p><ol><li>互斥：该资源任意一个时刻只由一个线程占用。</li><li>占有并等待：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。如一组等待线程{P0,P1,…Pn}，P0等待的资源被P1占有，P1等待的资源被P2占有，…，Pn等待的资源被P1占有。</li></ol></li><li><h4 id="如何避免线程死锁"><a href="#如何避免线程死锁" class="headerlink" title="如何避免线程死锁?"></a>如何避免线程死锁?</h4><p>只要破坏产生死锁的四个条件中的其中一个就可以了！</p><ul><li><p>破坏互斥条件：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）</p></li><li><p>破坏占有并等待条件：一次性申请所有的资源。</p></li><li><p>破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p><p>例：使用显式锁中的ReentrantLock.try(long,TimeUnit)来申请锁</p></li><li><p>破坏循环等待条件：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。</p><p>例：锁<a href="https://www.nowcoder.com/jump/super-jump/word?word=排序" target="_blank" rel="noopener">排序</a>法：（必须回答出来的点） 指定获取锁的顺序，比如某个线程只有获得A锁和B锁，才能对某资源进行操作，在多线程条件下，如何避免死锁？ 通过指定锁的获取顺序，比如规定，只有获得A锁的线程才有资格获取B锁，按顺序获取锁就可以避免死锁。这通常被认为是解决死锁很好的一种方法。</p></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>抽象类与接口</title>
      <link href="/2021/09/24/chou-xiang-lei-yu-jie-kou/"/>
      <url>/2021/09/24/chou-xiang-lei-yu-jie-kou/</url>
      
        <content type="html"><![CDATA[<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>abstarct关键字可以修饰类，表示这是一个抽象类。</p><p>抽象类中可以有非抽象方法，也可以有抽象方法。</p><p>抽象类甚至可以没有抽象方法，全是普通方法；但是定义一个抽象方法一定要放在一个抽象类中。</p><p>抽象方法即用abstract修饰的方法。这是一种约束，表示我们希望子类帮我们实现。因此，抽象方法只有方法名字，而没有方法的实现。例如：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 抽象类</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Service</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 抽象方法</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>而一个类如果想要继承抽象类，有两种方法：</p><ol><li>自己也声明为抽象类，继续等待下一个有缘人去实现抽象方法</li><li>实现所有的抽象方法（通过重写）</li></ol><p>另外，抽象类不能实例化，只能靠子类去实现它。（本质是一种模板）。</p><p>这并不是说抽象类没有构造方法。其实是有的。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>Java的类是单继承的，抽象类也不例外。而接口则可以实现多继承。</p><p>上面说到抽象类可以有普通方法（拥有方法实现），而接口只有抽象方法。所以说，接口是一个纯纯的规范：告诉你要具有哪些功能，但不指出具体该怎么实现。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同步/异步IO 阻塞/非阻塞IO</title>
      <link href="/2021/09/20/tong-bu-yi-bu-io-zu-sai-fei-zu-sai-io/"/>
      <url>/2021/09/20/tong-bu-yi-bu-io-zu-sai-fei-zu-sai-io/</url>
      
        <content type="html"><![CDATA[<h2 id="同步IO和异步IO的区别"><a href="#同步IO和异步IO的区别" class="headerlink" title="同步IO和异步IO的区别"></a>同步IO和异步IO的区别</h2><p>首先说明一个概念：一个IO操作，可分为两步。以一个套接字上的输入操作为例：</p><p>第一步涉及等待数据从网络中到达。当所有等待分组到达时，它被<code>复制到内核中的某个缓冲区</code>。</p><p>第二步就是把数据从<code>内核缓冲区复制到应用程序缓冲区</code>。</p><p>下面可以看看同步IO和异步IO的区别</p><ul><li><p>同步IO：应用进程发起IO请求的系统调用后，</p><p>可以是阻塞IO：即进程一直阻塞着，直到内核中的缓冲区数据就绪、内核空间到用户空间的拷贝就绪</p><p><img src=".%5C%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5IO-%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9EIO%5CBIO.jpg" alt=""></p><p>也可以是非阻塞IO：请求立刻返回，通过不断轮询，直到内核空间的数据准备好</p><p><img src="C:%5Ccode%5Cgit%5ChhhOscar.github.io%5Csource_posts%5C%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5IO-%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9EIO%5CNIO.jpg" alt=""></p><p>但总之同步IO有个特点：在将数据从内核空间拷贝到用户空间的过程中，即一个IO操作的第二步，进程得乖乖的等着</p></li><li><p>异步IO：进程发起IO请求后，可以当甩手掌柜了；等一切就绪，内核会通知进程。</p><p><img src="C:%5Ccode%5Cgit%5ChhhOscar.github.io%5Csource_posts%5C%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5IO-%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9EIO%5CAsyn.jpg" alt="Asyn"></p></li></ul><p>再来看IO多路复用（epoll也是一样的道理），是不是明白为啥是同步非阻塞IO了？</p><p><img src="C:%5Ccode%5Cgit%5ChhhOscar.github.io%5Csource_posts%5C%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5IO-%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9EIO%5CMulti.jpg" alt=""></p><p>虽然IO多路复用中IO操作的第一步，可以实现为阻塞的（阻塞等待，直到任意socket可读），也可以实现为非阻塞的（立即返回，但需要不断轮询，直到任意socket可读）。</p><p>但是在IO操作的第二步，在将数据从内核空间拷贝到用户空间的过程中是阻塞的，那它就是同步的，算不上异步IO。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AQS源码之-（一）独占锁的获取与释放</title>
      <link href="/2021/09/10/aqs-yuan-ma-zhi-yi-du-zhan-suo-de-huo-qu-yu-shi-fang/"/>
      <url>/2021/09/10/aqs-yuan-ma-zhi-yi-du-zhan-suo-de-huo-qu-yu-shi-fang/</url>
      
        <content type="html"><![CDATA[<h1 id="AQS源码之-（一）独占锁的获取与释放"><a href="#AQS源码之-（一）独占锁的获取与释放" class="headerlink" title="AQS源码之-（一）独占锁的获取与释放"></a>AQS源码之-（一）独占锁的获取与释放</h1><p>AQS是什么？</p><ul><li><p>AQS是 Java 中众多锁以及并发工具的基础。</p></li><li><p>AQS（AbstractQueuedSynchronizer）是一个实现<code>获取锁</code>功能的<code>框架</code>，同时它是一个<code>抽象类</code>。这代表着：</p><p>获取锁的实际逻辑交给子类去实现，就锁的获取操作而言，子类必须重写<code>tryAcquire()</code>方法。怎么强制你的子类重写呢？</p><p>AQS虽然是一个抽象类，但它出于设计上的考虑，却不含任何抽象方法。因为AQS是被设计来支持多种用途的，如果定义抽象方法，则子类在继承时必须要覆写所有的抽象方法，这显然是不合理的。</p><p>所以AQS将一些需要子类覆写的方法都设计成protect方法，将其默认实现为抛出UnsupportedOperationException异常。如果子类使用到这些方法，但是没有覆写，则会抛出异常；如果子类没有使用到这些方法，则不需要做任何操作。</p></li></ul><p>本篇我们将以ReentrantLock的公平锁为例来详细看看使用AQS获取独占锁的流程。<br>本文中的源码基于<code>JDK1.8</code> 。</p><h2 id="Java并发工具类的三要素"><a href="#Java并发工具类的三要素" class="headerlink" title="Java并发工具类的三要素"></a>Java并发工具类的三要素</h2><p>在开始看AQS源码之前，我们先来了解以下java并发工具的设计套路，我把它总结成三板斧：</p><p><code>状态</code>，<code>队列</code>，<code>CAS</code></p><p>每当我们学习一个Java并发编程工具的时候，我们首先要抓住这三点。</p><ol><li><p><strong>状态</strong>：一般是一个<code>state</code>属性，它基本是整个工具的核心，通常整个工具都是在设置和修改状态，很多方法的操作都依赖于当前状态是什么。由于状态是全局共享的，一般会被设置成volatile类型，以保证其修改的可见性；</p></li><li><p><strong>队列</strong>：队列通常是一个<code>等待的集合</code>，大多数以链表的形式实现。队列采用的是悲观锁的思想，表示当前所等待的资源、状态或者条件短时间内无法满足。因此，它会将当前线程包装成某种数据结构，扔到一个等待队列中，当一定条件满足后，再从等待队列中取出。</p></li><li><p><strong>CAS</strong>: CAS是一个原子操作，是<code>最轻量</code>的并发处理。通常我们对于状态的修改都会用到CAS操作，因为状态可能被多个线程同时修改，CAS操作保证了同一个时刻，只有一个线程能修改成功，从而保证了线程安全。</p><p>CAS操作基本是由Unsafe工具类的compareAndSwapXXX来实现的；CAS采用的是<code>乐观锁</code>的思想，因此常常伴随着<code>自旋</code>，如果发现当前无法成功地执行CAS，则不断重试，直到成功为止，自旋的的表现形式通常是一个死循环for(;;)</p></li></ol><h2 id="AQS核心实现"><a href="#AQS核心实现" class="headerlink" title="AQS核心实现"></a>AQS核心实现</h2><p>上面我们已经总结了java并发工具的套路，下面我们就以这个套路为切入点来分析AQS的实现。</p><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>在AQS中，状态是由state属性来表示的，不出所料，它是volatile类型的：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> state<span class="token punctuation">;</span></code></pre><p>该属性的值即表示了锁的状态，state为0表示锁没有被占用，而state大于0在不同类型的锁实现上有不同的语义：</p><ol><li>独占模式下：获取锁后state值加1，释放锁后state值减1，通过CAS原子操作加减，<code>state==0</code>表可以获取锁，<code>state&gt;1</code>代表锁重入。</li><li>共享模式下，<code>state&gt;0</code>代表可以获取锁，因为同步器初始化的时候，会给state设置一个初始值<code>n</code>，这个值代表同时允许<code>n</code>个线程获取锁表示当前已经有线程持有该锁。</li></ol><p>由于本篇我们分析的是独占锁，同一时刻，锁只能被一个线程所持有。通过state变量是否为0，我们可以分辨当前锁是否被占用。</p><p>但光知道锁是不是被占用是不够的，我们并不知道占用锁的线程是哪一个。在监视器锁中，我们用ObjectMonitor对象的_owner属性记录了当前拥有监视器锁的线程，而在AQS中，我们将通过exclusiveOwnerThread属性来表示当前持有锁的线程 ：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">transient</span> Thread exclusiveOwnerThread<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//继承自AbstractOwnableSynchronizer</span></code></pre><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>接着我们来看看队列是怎么实现的。在AQS中，队列的实现是一个双向链表（非循环），被称为AQS中，队列的实现是一个双向链表，被称为sync queue。它表示所有等待锁的线程的集合，有点类似于我们前面介绍synchronized原理的时候说的wait set。</p><p>我们前面说过，在并发工具类中使用队列通常是将当前线程包装成某种类型的数据结构扔到等待队列中，我们先来看看队列中的每一个节点是怎么个数据结构：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** Marker to indicate a node is waiting in shared mode */</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> Node SHARED <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** Marker to indicate a node is waiting in exclusive mode */</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> Node EXCLUSIVE <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** waitStatus value to indicate thread has cancelled */</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CANCELLED <span class="token operator">=</span>  <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** waitStatus value to indicate successor's thread needs unparking */</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SIGNAL    <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** waitStatus value to indicate thread is waiting on condition */</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CONDITION <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**    * waitStatus value to indicate the next acquireShared should    * unconditionally propagate    */</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> PROPAGATE <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">volatile</span> <span class="token keyword">int</span> waitStatus<span class="token punctuation">;</span>    <span class="token keyword">volatile</span> Node prev<span class="token punctuation">;</span>    <span class="token keyword">volatile</span> Node next<span class="token punctuation">;</span>    <span class="token keyword">volatile</span> Thread thread<span class="token punctuation">;</span>    Node nextWaiter<span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">isShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> nextWaiter <span class="token operator">==</span> SHARED<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">final</span> Node <span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> NullPointerException <span class="token punctuation">{</span>        Node p <span class="token operator">=</span> prev<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Used to establish initial head or SHARED marker</span>    <span class="token punctuation">}</span>    <span class="token function">Node</span><span class="token punctuation">(</span>Thread thread<span class="token punctuation">,</span> Node mode<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// Used by addWaiter</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>nextWaiter <span class="token operator">=</span> mode<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> thread<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">Node</span><span class="token punctuation">(</span>Thread thread<span class="token punctuation">,</span> <span class="token keyword">int</span> waitStatus<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// Used by Condition</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>waitStatus <span class="token operator">=</span> waitStatus<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> thread<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这个结构看上去很复杂，实际上属性可分成4类：</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// 节点所代表的线程</span>    <span class="token keyword">volatile</span> Thread thread<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 双向链表，每个节点需要保存自己的前驱节点和后继节点的引用</span>    <span class="token keyword">volatile</span> Node prev<span class="token punctuation">;</span>    <span class="token keyword">volatile</span> Node next<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 线程所处的等待锁的状态，初始化时，该值为 0</span>    <span class="token keyword">volatile</span> <span class="token keyword">int</span> waitStatus<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CANCELLED <span class="token operator">=</span>  <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SIGNAL    <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CONDITION <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> PROPAGATE <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 该属性用于条件队列或者共享锁</span>    Node nextWaiter<span class="token punctuation">;</span></code></pre><p>注意，在这个Node类中有一个状态变量waitStatus，它表示了当前Node所代表的线程的等待锁的状态，在<code>独占锁</code>模式下，我们只需要关注<code>CANCELLED</code>、<code>SIGNAL</code>两种状态即可（还有<code>初始状态</code>，waitStatus==0）。</p><p>这里还有一个nextWaiter属性，它在独占锁模式下永远为null，仅仅起到一个标记作用，没有实际意义。这么一分析，这个Node类是不是就简单了好多？</p><p>说完队列中的节点，我们接着说回这个sync queue。AQS是怎么使用这个队列的呢？既然是双向链表，操纵它自然只需要一个头结点和一个尾节点：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 头结点，不代表任何线程，是一个哑结点</span><span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> Node head<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 尾节点，每一个请求锁的线程会加到队尾</span><span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> Node tail<span class="token punctuation">;</span></code></pre><h2 id="AQS的实现类"><a href="#AQS的实现类" class="headerlink" title="AQS的实现类"></a>AQS的实现类</h2><p>我们常说 ReentrantLock 是 AbstractQueuedSynchronizer 的实现类。实际上我们在创建一个 ReentrantLock 对象的时候，创建的是 ReentrantLock 中的一个内部类，按照需要可以创建公平锁 / 非公平锁（默认）：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReentrantLock</span> <span class="token keyword">implements</span> <span class="token class-name">Lock</span><span class="token punctuation">,</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** Synchronizer providing all implementation mechanics */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> Sync sync<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**         * Base of synchronization control for this lock. Subclassed         * into fair and nonfair versions below. Uses AQS state to         * represent the number of holds on the lock.         */</span>    <span class="token keyword">abstract</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Sync</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**    真正的操作对象 两个类都extends了Sync类    而 Sync类 是 AbstractQueuedSynchronizer的抽象实现类    */</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">NonfairSync</span> <span class="token keyword">extends</span> <span class="token class-name">Sync</span><span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">FairSync</span> <span class="token keyword">extends</span> <span class="token class-name">Sync</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**    根据构造函数可以看出：    实例化一个ReentrantLock,本质上是实例化了一个内部类    根据boolean值fair，指定是否是公平锁    */</span>    <span class="token keyword">public</span> <span class="token function">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        sync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">ReentrantLock</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">{</span>        sync <span class="token operator">=</span> fair <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">FairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**    调用一个ReentrantLock对象的lock unlock方法    实际上是映射到对sync这个对象进行操作    */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        sync<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        sync<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>所谓的公平锁、非公平锁的区别，在于非公平锁在几个地方给当前想要获取锁的线程开了后门。</p><p>这是FairSync 类实现的lock方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>安分守己，默默的调用acquire(arg=1)方法。</p><p>再看 NonfairSync类实现的lock方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>即便队列中还有排队的线程，只要state==0，说明线程还在唤醒过程中，这个时候，正在运行的当前线程可以插队，直接通过cas占用锁。</p><h3 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h3><p>acquire方法定义在AQS中，并且不允许子类重写。但它调用了tryAcquire方法。tryAcquire是强制子类重写的，这也是AQS将尝试获取锁的逻辑开放给子类去个性化实现的体现。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span>Node<span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="tryAcquire"><a href="#tryAcquire" class="headerlink" title="tryAcquire"></a>tryAcquire</h4><p>再来看，在tryAcquire中，NonfairSync也整了些幺蛾子：</p><p>这是FairSync 类 实现的tryAcquire方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> Thread current <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>            <span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 如果state==0，还要前面没有排队的线程，才能cas获取锁</span>            <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果state!=0,还有机会：如果是重入的情况，说明当前线程已经持有锁；更新state值即可（都不用cas，因为已经持有了锁）</span>        <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 更新都不需要cas，因为已经持有了锁</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>NonfairSync的代码几乎一样，就是缺少了第5行对<code>!hasQueuedPredecessors()</code>的判断</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">nonfairTryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> Thread current <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// overflow</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>“走后门”的条件还是一样：state的值是0。只要state显示锁还没有被哪个线程占用，即使队列中有线程Node，直接插队即可。</p><h4 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span>Node<span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>tryAcquire能直接成功获得锁的概率不怎么高，这时候就会走到<code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code></p><p>，这是可以保证线程获得锁的操作。我们从内往外分析，先来看addWaiter(Node.EXCLUSIVE)方法:</p><h5 id="addWaiter-Node-EXCLUSIVE"><a href="#addWaiter-Node-EXCLUSIVE" class="headerlink" title="addWaiter(Node.EXCLUSIVE)"></a>addWaiter(Node.EXCLUSIVE)</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> Node <span class="token function">addWaiter</span><span class="token punctuation">(</span>Node mode<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将当前线程包装成Node</span>    <span class="token comment" spellcheck="true">// 这里我们用注释的形式把Node的构造函数贴出来</span>    <span class="token comment" spellcheck="true">// 因为传入的mode值为Node.EXCLUSIVE，所以节点的nextWaiter属性被设为null</span>    <span class="token comment" spellcheck="true">/*        static final Node SHARED = new Node();        static final Node EXCLUSIVE = null;        Node(Thread thread, Node mode) {     // Used by addWaiter            this.nextWaiter = mode;            this.thread = thread;        }    */</span>    Node pred <span class="token operator">=</span> tail<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// tail不为null说明队列已经初始化过, 则用CAS方式将当前节点设为尾节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            pred<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>            <span class="token keyword">return</span> node<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 代码会执行到这里, 只有两种情况:</span>    <span class="token comment" spellcheck="true">//    1. 队列还没有初始化（head和tail都还是null）</span>    <span class="token comment" spellcheck="true">//    2. CAS失败</span>    <span class="token comment" spellcheck="true">// 注意, 这里是并发条件下, 所以什么都有可能发生, 尤其注意CAS失败后也会来到这里</span>    <span class="token function">enq</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将节点插入队列</span>    <span class="token keyword">return</span> node<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>可见，每一个处于独占锁模式下的节点，它的nextWaiter一定是null。<br>在这个方法中，我们首先会尝试直接入队，但是因为目前是在并发条件下，所以有可能同一时刻，有多个线程都在尝试入队，导致compareAndSetTail(pred, node)操作失败——因为有可能其他线程已经成为了新的尾节点，导致尾节点不再是我们之前看到的那个pred了。</p><p>如果入队失败了，接下来我们就需要调用enq(node)方法，在该方法中我们将通过自旋+CAS的方式，确保当前节点入队。</p><h6 id="enq方法"><a href="#enq方法" class="headerlink" title="enq方法"></a>enq方法</h6><p>能执行到enq方法，说明当前线程获取锁已经失败了，我们已经把它包装成一个Node,准备把它扔到等待队列中去，但是在这一步又失败了。这个失败的原因可能是以下两种之一：</p><ol><li>等待队列还没有初始化。</li><li>其他线程在当前线程入队的过程中率先完成了入队，导致尾节点的值已经改变了，CAS操作失败。</li></ol><p>在该方法中, 我们使用了死循环, 即以自旋方式将节点插入队列，如果失败则不停的尝试, 直到成功为止, 另外, 该方法也负责在队列为空时, 初始化队列，这也说明，队列是延时初始化的(lazily initialized)：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> Node <span class="token function">enq</span><span class="token punctuation">(</span><span class="token keyword">final</span> Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node t <span class="token operator">=</span> tail<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 对应第一种情况:如果是队列还没有初始化, 首先进行初始化</span>        <span class="token comment" spellcheck="true">// 这里也可以看出, 队列不是在构造的时候初始化的, 而是延迟到需要节点入队的时候再初始化, 以提升性能</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">// 初始化时使用new Node()方法新建了一个dummy节点,作为head节点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetHead</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                tail <span class="token operator">=</span> head<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 这里仅仅是将尾节点指向dummy节点，并没有返回</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 到这里说明队列已经初始化了, 这个时候再通过cas+死循环，将节点加到队尾</span>            node<span class="token punctuation">.</span>prev <span class="token operator">=</span> t<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                t<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>                <span class="token keyword">return</span> t<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这里尤其要注意的是，当队列没有初始化，head和tail都还是null的时候，我们初始化队列并没有使用当前传进来的节点作为head节点，而是：</p><p>新建了一个空节点！！！</p><p>在新建完空的头节点之后，我们并没有立即返回，而是将尾节点指向当前的头节点。这就是初始化的全部工作。然而并不return，而是进入下一轮循环。</p><p>在下一轮循环中，尾节点已经不为null了，此时再将我们包装了当前线程的Node加到这个空节点后面。</p><p>这就意味着，在这个等待队列中，头结点是一个“哑节点”，它不代表任何等待的线程。</p><p>因此，我们判断队列是否初始化过，用的是tail == null ?</p><p>而判断队列中有没有排队的线程，用的是 head == tail ?</p><p>与将大象放到冰箱里需要三步一样，将一个节点node添加到sync queue的末尾也需要三步：</p><ol><li>设置node的前驱节点为当前的尾节点：node.prev = t</li><li>CAS修改tail属性，使它指向当前节点</li><li>修改原来的尾节点，使它的next指向当前节点<br><img src=".%5CAQS%E6%BA%90%E7%A0%81%E4%B9%8B-%EF%BC%88%E4%B8%80%EF%BC%89%E7%8B%AC%E5%8D%A0%E9%94%81%E7%9A%84%E8%8E%B7%E5%8F%96%E4%B8%8E%E9%87%8A%E6%94%BE%5Cenq-loop.jpg" alt=""></li></ol><p>但是需要注意的，这里的三步并不是一个原子操作，第一步很容易成功；而第二步由于是一个CAS操作，在并发条件下有可能失败，第三步只有在第二步成功的条件下才执行。这里的CAS保证了同一时刻只有一个节点能成为尾节点，其他节点将失败，失败后将回到for循环中继续重试。</p><p>所以，当有大量的线程在同时入队的时候，同一时刻，只有一个线程能完整地完成这三步，而其他线程只能完成第一步，于是就出现了尾分叉。</p><p>注意，这里第三步是在第二步执行成功后才执行的，这就意味着，有可能即使我们已经完成了第二步，将新的节点设置成了尾节点，此时原来旧的尾节点 t 的next值可能还是null(因为还没有来的及执行第三步)，所以如果此时有线程恰巧从头节点开始向后遍历整个链表，则它是遍历不到新加进来的尾节点的，但是这显然是不合理的，因为现在的tail已经指向了新的尾节点。<br>另一方面，当我们完成了第二步之后，第一步一定是完成了的，所以如果我们从尾节点开始向前遍历，已经可以遍历到所有的节点。这也就是为什么我们在AQS相关的源码中，有时候常常会出现<code>从尾节点开始逆向遍历链表</code>——因为一个节点要能入队(指将tail指针指向它)，则它的prev属性一定是有值的，但是指向它的next指针可能暂时还没有值。</p><p>至于那些“分叉”的入队失败的其他节点，在下一轮的循环中，它们的prev属性会重新指向新的尾节点，继续尝试新的CAS操作，最终，所有节点都会通过自旋不断的尝试入队，直到成功为止。</p><h6 id="addWaiter总结"><a href="#addWaiter总结" class="headerlink" title="addWaiter总结"></a>addWaiter总结</h6><p>至此，我们就完成了addWaiter(Node.EXCLUSIVE)方法的完整的分析，该方法并不设计到任何关于锁的操作，它就是解决了<code>并发条件下的节点入队问题</code>。具体来说就是该方法保证了将当前线程包装成Node节点加入到等待队列的队尾，如果队列尚未初始化，则会新建一个dummy节点作为头节点和尾节点，再将当前节点接在尾节点的后面。</p><p>addWaiter(Node.EXCLUSIVE)方法最终返回了代表了当前线程的Node节点，在返回的那一刻，这个节点必然是当时的sync queue的尾节点。</p><p>不过值得注意的是，enq方法也是有返回值（虽然这里我们并没有使用它的返回值），但是它返回的是node节点的前驱节点（旧tail节点），这个返回值虽然在addWaiter方法中并没有使用，但是在其他地方会被用到。</p><p>我们再回顾获取锁的逻辑：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span>Node<span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>当addWaiter(Node.EXCLUSIVE)执行完毕后，节点现在已经被成功添加到sync queue中了，并将节点作为返回值。接下来将执行acquireQueued方法。</p><h5 id="acquireQueued-1"><a href="#acquireQueued-1" class="headerlink" title="acquireQueued"></a>acquireQueued</h5><p>该方法是最复杂的一个方法, 也是最难啃的骨头, 看代码之前首先简单的说明几点:</p><ol><li>能执行到该方法, 说明addWaiter 方法已经成功将包装了当前Thread的Node添加到了等待队列的队尾</li><li>该方法中将再次尝试去获取锁</li><li>在再次尝试获取锁失败后, 判断是否需要把当前线程挂起</li></ol><p>为什么前面获取锁失败了, 这里还要再次尝试获取锁呢？首先, 这里再次尝试获取锁是基于一定的条件的,即:</p><p>当前节点的前驱节点就是head节点</p><p>因为我们知道，head节点就是个虚拟节点，它不代表任何线程（或者代表着当前持有锁的线程），如果当前节点的前驱节点就是head节点，那就说明当前节点已经是排在整个等待队列最前面的了。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token keyword">final</span> Node node<span class="token punctuation">,</span> <span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> Node p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 在当前节点的前驱就是HEAD节点时, 再次尝试获取锁</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                p<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// help GC</span>                failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> interrupted<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//在获取锁失败后, 判断是否需要把当前线程挂起</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span>            <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>failed变量作用不大，仅用来在出现异常的时候调用cancelAcquire(node)方法。重点来看for (;;)代表的自旋操作。在循环体中出现了两个分支：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> Node p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 在当前节点的前驱就是head节点时, 再次尝试获取锁</span><span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    p<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// help GC</span>    failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> interrupted<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>首先我们获取尾节点的前驱节点（因为上一步addWaiter()方法返回的就是尾节点，并且这个节点就是代表了当前线程的Node），如果前驱节点就是head节点，那说明当前线程已经排在了队列的最前面，所以这里我们再试着去获取锁。如果这一次获取成功了，即tryAcquire方法返回了true, 则我们将进入if代码块，调用setHead方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">setHead</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    head <span class="token operator">=</span> node<span class="token punctuation">;</span>    node<span class="token punctuation">.</span>thread <span class="token operator">=</span> null<span class="token punctuation">;</span>    node<span class="token punctuation">.</span>prev <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这个方法将head指向传进来的node,并且将node的thread和prev属性置为null。结合acquireQueued方法中的第10行代码，实际上做了3件事：</p><ol><li><p>原来的head出队，对应的Node对象被回收。</p></li><li><p>将head指向已经获得了锁的node。</p></li><li><p>将当前head节点的thread属性置为null，这某种意义上导致了这个新的head节点又成为了一个dummy节点，它不代表任何线程。</p><p>为什么要这样做呢，我的理解是因为在tryAcquire调用成功后，exclusiveOwnerThread属性就已经记录了当前获取锁的线程了，此处没有必要再记录。</p></li></ol><p>接下来我们再来看看另一种情况，即p == head &amp;&amp; tryAcquire(arg)返回了false，此时我们需要判断是否需要将当前线程挂起：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//在CAS获取锁失败后, 判断是否需要把当前线程挂起</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></code></pre><p>从shouldParkAfterFailedAcquire这个函数名可以看出, 该方法用于判断在获取锁失败后, 是否将线程挂起。<code>而决定的依据就是前驱节点的waitStatus值</code>。</p><p>（有没发现一直到现在，前面的分析中我们都没有用到waitStatus的值，终于在这里要用到了）</p><p>我们先来回顾一下waitStatus有哪些状态值：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CANCELLED <span class="token operator">=</span>  <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SIGNAL    <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CONDITION <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> PROPAGATE <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">;</span></code></pre><p>一共有四种状态，但是我们在开篇的时候就说过，在独占锁锁的获取操作中，我们只用到了其中的两个——<code>CANCELLED</code>和<code>SIGNAL</code>。<br>当然，前面我们在创建节点的时候并没有给waitStatus赋值，因此每一个节点最开始的时候waitStatus的值都被初始化为0，即不属于上面任何一种状态。</p><p>那么<code>CANCELLED</code>和<code>SIGNAL</code>代表什么意思呢？</p><p><code>CANCELLED</code>状态很好理解，它表示Node所代表的当前线程已经取消了排队，即放弃获取锁了。</p><p><code>SIGNAL</code>这个状态就有点意思了，它不是表征当前节点的状态，而是当前节点的下一个节点的状态。<br>当一个节点的waitStatus被置为<code>SIGNAL</code>，就说明它的下一个节点（即它的后继节点）已经被挂起了（或者马上就要被挂起了），因此<code>SIGNAL</code>的语义是：当前节点释放锁或者放弃获取锁时，如果它的waitStatus属性为<code>SIGNAL</code>，它还要完成一个额外的操作——唤醒它的后继节点。</p><p>更有意思的是，SIGNAL这个状态的设置常常不是节点自己给自己设的，而是后继节点设置的，这里给大家打个比方：</p><p>比如说出去吃饭，在人多的时候经常要排队取号，你取到了8号，前面还有7个人在等着进去，你就和排在你前面的7号讲“哥们，我现在排在你后面，队伍这么长，估计一时半会儿也轮不到我，我去那边打个盹，一会轮到你进去了(release)或者你不想等了(cancel), 麻烦你都叫醒我”，说完，你就把这个哥们的waitStatus值设成了<code>SIGNAL</code>。</p><p>换个角度讲，当我们决定要<code>将一个线程挂起之前</code>，首先要确保自己的<code>前驱节点</code>的waitStatus为<code>SIGNAL</code>，这就相当于给自己设一个<code>闹钟</code>再去睡，这个闹钟会在恰当的时候叫醒自己，否则，如果一直没有人来叫醒自己，自己可能就一直睡到天荒地老了。</p><p>理解了<code>CANCELLED</code>和<code>SIGNAL</code>这两个状态的含义后，我们再来看看shouldParkAfterFailedAcquire是怎么用的：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>Node pred<span class="token punctuation">,</span> Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> ws <span class="token operator">=</span> pred<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 获得前驱节点的ws</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">==</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 前驱节点的状态已经是SIGNAL了，说明闹钟已经设了，可以直接park了</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 当前节点的 ws > 0, 只有Node.CANCELLED 说明前驱节点已经取消了等待锁(由于超时或者中断等原因)</span>        <span class="token comment" spellcheck="true">// 既然前驱节点不等了, 那就继续往前找, 直到找到一个还在等待锁的节点</span>        <span class="token comment" spellcheck="true">// 然后我们跨过这些不等待锁的节点, 直接排在等待锁的节点的后面 (是不是很开心!!!)</span>        <span class="token keyword">do</span> <span class="token punctuation">{</span>            node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred <span class="token operator">=</span> pred<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>pred<span class="token punctuation">.</span>waitStatus <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pred<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 前驱节点的状态既不是SIGNAL，也不是CANCELLED</span>        <span class="token comment" spellcheck="true">// 用CAS设置前驱节点的ws为 Node.SIGNAL，给自己定一个闹钟</span>        <span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>可以看出，shouldParkAfterFailedAcquire所做的事情无外乎：</p><ol><li>如果为前驱节点的waitStatus值为 <code>Node.SIGNAL</code> 则直接返回 true</li><li>如果为前驱节点的waitStatus值为 <code>Node.CANCELLED</code> (ws &gt; 0), 则跳过那些节点, 重新寻找正常等待中的前驱节点，然后排在它后面，返回false</li><li>其他情况, 将前驱节点的状态改为 <code>Node.SIGNAL</code>, 返回false</li></ol><p>【warning】这个函数只有在当前节点的前驱节点的waitStatus状态本身就是<code>SIGNAL</code>的时候才会返回<code>true</code>, 其他时候都会返回<code>false</code>。这又是为什么呢？我们再回到这个方法的调用处：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token keyword">final</span> Node node<span class="token punctuation">,</span> <span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> Node p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 在当前节点的前驱就是HEAD节点时, 再次尝试获取锁</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                p<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// help GC</span>                failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> interrupted<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//在获取锁失败后, 判断是否需要把当前线程挂起</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span>            <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>可以看出，当shouldParkAfterFailedAcquire返回false后，会继续回到循环中再次尝试获取锁——这是因为此时我们的前驱节点可能已经变了（搞不好前驱节点就变成head节点了呢）。</p><p>当shouldParkAfterFailedAcquire返回true，即当前节点的前驱节点的waitStatus状态已经设为<code>SIGNAL</code>后，我们就可以安心的将当前线程挂起了，此时我们将调用parkAndCheckInterrupt：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    LockSupport<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 通过调用native方法将线程挂起，停在这里不再往下执行了</span>    <span class="token keyword">return</span> Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>注意！LockSupport.park(this)执行完成后线程就被挂起了，除非其他线程unpark了当前线程，或者当前线程被中断了，否则代码是不会再往下执行的，后面的Thread.interrupted()也暂时不会被执行，直到线程获取了锁，线程会从lock()方法返回，继续往下执行。</p><h3 id="release-int-arg"><a href="#release-int-arg" class="headerlink" title="release(int arg)"></a>release(int arg)</h3><p>讲完独占锁的获取操作, 接下来看看独占锁的释放。</p><p>先提一嘴，ReentrantLock这个AQS的子类，作为显式锁，需要自己显式的释放锁, 所以在加锁之后一定不要忘记在finally块中进行显式的锁释放:</p><pre class=" language-java"><code class="language-java">Lock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 更新对象</span>    <span class="token comment" spellcheck="true">//捕获异常</span><span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>    lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>由于锁的释放操作对于公平锁和非公平锁都是一样的, 所以, unlock的逻辑并没有放在 FairSync 或 NonfairSync 里面, 而是直接定义在 ReentrantLock类中:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    sync<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>而release(int arg)方法定义在AQS中，由final修饰，禁止重写：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryRelease</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node h <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>释放锁的过程要简单很多, 它只涉及到两个子函数的调用:</p><ul><li><p>tryRelease(arg) : </p><p>该方法由继承AQS的子类实现, 为释放锁的具体逻辑</p></li><li><p>unparkSuccessor(h)</p><p>唤醒h的后继线程</p></li></ul><h4 id="tryRelease-int-releases"><a href="#tryRelease-int-releases" class="headerlink" title="tryRelease(int releases)"></a>tryRelease(int releases)</h4><p>tryRelease方法由ReentrantLock的静态类Sync实现:</p><p>多嘴提醒一下, 能执行到释放锁的线程, 一定是已经获取了锁的线程(这不废话嘛!)</p><p>也因为如此，相比获取锁的操作, 这里并没有使用任何CAS操作：当前线程已经持有了锁, 所以可以直接安全的操作, 不会产生竞争。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 首先将当前持有锁的线程个数减1(回溯到调用源头sync.release(1)可知, releases的值为1)</span>    <span class="token comment" spellcheck="true">// 这里的操作主要是针对可重入锁的情况下, c可能大于1</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> releases<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 释放锁的线程当前必须是持有锁的线程，不然抛出异常</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果c==0了, 说明锁已经完全释放了</span>    <span class="token keyword">boolean</span> free <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        free <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">setState</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> free<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="unparkSuccessor-Node-node"><a href="#unparkSuccessor-Node-node" class="headerlink" title="unparkSuccessor(Node node)"></a>unparkSuccessor(Node node)</h4><p>执行完tryRelease方法，就知道当前线程是否完全释放了锁（对state的修改一定会成功，但不一定减到了0）。如果锁成功释放了, 接下来就是通过unparkSuccessor唤醒后继节点了, 这个方法同样定义在AQS中。</p><p>值得注意的是, 在成功释放锁之后(tryRelease 返回 true之后)，唤醒后继节点是一个 “附加操作”，无论该操作结果怎样, 最后 release 操作都会返回 true。</p><p>即：release的语义是：当前线程的锁是否被完全释放了。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryRelease</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node h <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>看看unparkSuccessor的源码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> ws <span class="token operator">=</span> node<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果head节点的ws比0小, 则直接将它设为0</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 通常情况下, 要唤醒的节点就是自己的后继节点</span>    <span class="token comment" spellcheck="true">// 如果后继节点存在且也在等待锁, 那就直接唤醒它</span>    <span class="token comment" spellcheck="true">// 但是有可能存在 后继节点取消等待锁 的情况</span>    <span class="token comment" spellcheck="true">// 此时从尾节点开始向前找起, 直到找到距离head节点最近的ws&lt;=0的节点</span>    Node s <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null <span class="token operator">||</span> s<span class="token punctuation">.</span>waitStatus <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        s <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Node t <span class="token operator">=</span> tail<span class="token punctuation">;</span> t <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> t <span class="token operator">!=</span> node<span class="token punctuation">;</span> t <span class="token operator">=</span> t<span class="token punctuation">.</span>prev<span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>waitStatus <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                s <span class="token operator">=</span> t<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 注意! 这里找到了之并有return, 而是继续向前找</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 如果找到了还在等待锁的节点,则唤醒它</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">!=</span> null<span class="token punctuation">)</span>        LockSupport<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP笔记-TCP篇</title>
      <link href="/2021/09/03/tcp-ip-bi-ji-tcp-pian/"/>
      <url>/2021/09/03/tcp-ip-bi-ji-tcp-pian/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP-IP笔记-TCP篇"><a href="#TCP-IP笔记-TCP篇" class="headerlink" title="TCP/IP笔记-TCP篇"></a>TCP/IP笔记-TCP篇</h1><h2 id="TCP介绍"><a href="#TCP介绍" class="headerlink" title="TCP介绍"></a>TCP介绍</h2><h3 id="TCP的服务"><a href="#TCP的服务" class="headerlink" title="TCP的服务"></a>TCP的服务</h3><p>首先TCP是向应用层提供服务，第二，TCP提供的是一种<code>面向连接的、可靠的字节流服务</code>。</p><ol><li><p>面向连接意味着：两个使用TCP协议通信的应用（通常一个是客户端，一个是服务器）在彼此交换数据之前，必须先建立一个TCP连接（三次握手）。</p><p>另外，在一个TCP连接中，仅有两方进行点对点通信（不支持广播和多播）</p></li><li><p>可靠意味着：⽆论的⽹络链路中出现了怎样的链路变化，TCP 都可以保证⼀个报⽂⼀定能够到达接收端。可靠性是靠多种机制来实现的。</p></li><li><p>字节流服务：消息是「没有边界」的，所以⽆论我们消息有多大都可以进行传输，TCP会自动把应用数据分割成它认为合适的大小的报文段进行发送。</p><p>TCP不会在字节流中插入任何记录标识符，即如果一方的应用程序先传10字节，又传20字节，再传50字节（应用层交给传输层），TCP可以想怎么传就怎么传，比如分四次发送这80个字节，每次发送20个；相应的，接收方的TCP并不知道发送方的应用程序每次发送了多少字节，它只是分四次接收了这80个字节，每次接收20个。接收方的TCP再往应用层交，同样是4个20字节。但可以保证的是：<code>一端将字节流放到TCP连接上，一模一样的字节流将出现在TCP连接的另一端。</code></p><p>另外，TCP不对字节流的内容做任何解释。TCP不会知道传输的数据字节流是二进制数据，还是ASCII字符。对字节流的解释，由TCP之上的应用层负责。</p></li></ol><h3 id="TCP的头格式"><a href="#TCP的头格式" class="headerlink" title="TCP的头格式"></a>TCP的头格式</h3><p><img src=".%5CTCP-IP%E7%AC%94%E8%AE%B0-TCP%E7%AF%87%5CTCP-header.jpg" alt=""></p><p><strong>端口号</strong>：标识应用程序（应用进程）。</p><p><strong>序列号</strong>：用来给从TCP发送端向TCP接收端发送的字节流做标记，它表示在当前报文段中的第一个数据字节。接收端会通过这个序列号判断是不是现在迫切想要的数据。</p><p>在建立连接时，由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送⼀次数据，就 「累加」⼀次该「数据部分字节数」的大小。用来解决网络包乱序问题。</p><p>特例：在发送SYN包（SYN位为1）或FIN包（FIN位为1）时，即使数据部分为空，TCP认为在这个方向上传输了一个字节的数据，序列号会增加 1 。相比之下，ACK被置位被认为是没有代价的，不需要增加序列号。</p><p><strong>确认应答号</strong>：上次已成功收到的数据字节序号 + 1，指下⼀次<code>期望</code>收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。⽤来解决丢包的问题。 </p><p><strong>4位首部长度</strong>：TCP的首部 + TCP的选项部分，最多 60 个字节。</p><p>为什么是60字节？1111换算成10进制是15，可理解成最多15行；而首部长度就是固定以4个字节为单位（一行4字节），所以最多15*4=60字节。</p><p><strong>控制位</strong>： </p><ul><li><strong>ACK</strong>：该位为 1 时，表示「确认应答号」的字段变为有效，TCP 规定除了最初建立连接时的 SYN 包之外，该位必须设置为 1，也就是必须确认应答。 </li><li><strong>RST</strong>：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。 </li><li><strong>SYN</strong>：该位为 1 时，表示希望建⽴连接，并在其「序列号」的字段进⾏序列号初始值的设定。 </li><li><strong>FIN</strong>：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位为 1 的 TCP 段。</li></ul><p><strong>窗口大小</strong>：表示接收方<code>可用</code>的缓存大小是多少。</p><h3 id="问答环节"><a href="#问答环节" class="headerlink" title="问答环节"></a>问答环节</h3><blockquote><p>如何唯⼀确定⼀个 TCP 连接呢？</p></blockquote><p>一个IP地址加一个端口号称为一个socket，那么一个socket pair（源ip+源端口+目的ip+目的端口）就可以唯一确定一个TCP连接的双方。</p><p>源ip地址和目的ip地址的字段（32位）是在 IP 头部中，作用是通过 IP 协议发送报文给对方主机。</p><p>源端口和目的端口的字段（16位）是在 TCP 头部中，作用是告诉 TCP 协议应该把报文交给哪个进程。</p><blockquote><p>不是说TCP没有在字节流中插入任何记录标识符吗？序列号又怎么解释？</p></blockquote><p>TCP没有在字节流中插入任何记录标识符，指的是应用层把数据交下来的时候，TCP没有用标识符记录每次操作分别传了多少个字节；但是TCP在发送一个报文段的时候，需要用序列号表示此报文段的数据从哪个字节开始，接收端可以通过这个字段，判断是不是当前等待的那个。如果是，就可以更新确认应答号，告诉发送端：现在我需要这个新的ACK Num指定的数据！如果不是，还是告诉发送端：原来的ACK Num开始的数据还没有收到，还是从这个位置开始重新给我发！因此，我们说TCP是一个<code>没有选择确认功能</code>的滑动窗口协议</p><h2 id="TCP连接的建立与断开"><a href="#TCP连接的建立与断开" class="headerlink" title="TCP连接的建立与断开"></a>TCP连接的建立与断开</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src=".%5CTCP-IP%E7%AC%94%E8%AE%B0-TCP%E7%AF%87%5CTCP-connect-establish.jpg" alt=""></p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><h2 id="TCP交互数据流"><a href="#TCP交互数据流" class="headerlink" title="TCP交互数据流"></a>TCP交互数据流</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NIO</title>
      <link href="/2021/08/30/nio/"/>
      <url>/2021/08/30/nio/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>https工作原理</title>
      <link href="/2021/08/30/https-gong-zuo-yuan-li/"/>
      <url>/2021/08/30/https-gong-zuo-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="https工作原理"><a href="#https工作原理" class="headerlink" title="https工作原理"></a>https工作原理</h1><p>故事的主人公是小周，他有三个好朋友曹、潘和孙。小周经常跟他们写信，因为他的信是明文传输的，在传递过程可能被人截获偷窥，也可能被人截获然后又篡改了，更有可能别人伪装成小周本人跟他的好朋友通信，总之是不安全的。</p><p>问题1：http协议是明文传输的，信息有被<code>窃听</code>的风险。</p><p>解决1：经过一番苦苦探索，诶，他发现计算机安全学里有一种叫非对称加密算法的东东，好像可以帮助他解决这个问题</p><p><strong>说明：非对称加密算法（RSA）是内容加密的一类算法，它有两个秘钥：公钥与私钥。公钥是公开的钥匙，所有人都可以知道，私钥是保密的，只有持有者知道。通过公钥加密的内容，只能通过私钥解开。非对称加密算法的安全性很高，但是因为计算量庞大，比较消耗性能。</strong></p><p>好了，来看看小周是怎么应用非对称加密算法与他的好朋友通信的：</p><ol><li>首先小周弄到了两把钥匙：公钥和私钥。</li><li>小周自己保留下了私钥，把公钥复制成三份送给了他的三个好朋友曹、潘和孙。</li><li>此时，小周总算可以安心地和他的好朋友愉快地通信了。比如孙要和他讨论关于去哪吃午饭的事情，孙就可以先把自己的内容（明文）用小周送给他的公钥做一次加密，然后把加密的内容传送给小周。小周收到信后，再用自己的私钥解开信的内容。就可以知道具体的内容啦</li></ol><p>问题2：http协议不验证通信方的身份，通信方有<code>伪装</code>的风险。</p><p>问题3：http协议不验证报文的完整性，信息有被<code>篡改</code>的风险。</p><p>解决2、3：</p><ol><li><p>小周看完信后，决定给孙回一封信。为了防止信的内容被篡改（或者别人伪装成他的身份跟孙通信），他决定先对信的内容用摘要算法（hash算法）做一次处理，得到一个字符串哈希值，小周又用自己的私钥对哈希值做了一次加密得到一个签名，然后把签名和信（明文的）一起发送给孙。</p><p><strong>说明：小周信的内容实质是明文传输的，所以这个过程是可以被人截获和窥探的，但是此时小周不担心被人窥探，他担心的是内容被人篡改或者有人冒充自己跟孙通信。这里其实涉及到了计算机安全学中的<code>认证</code>概念，小周要向孙证明通信的对方是小周本人，另外也需要确保自己的内容是完整的。</strong></p></li><li><p>孙接收到了小周的信，首先用小周给的公钥对签名作了解密处理，得到了哈希值A；</p><p>然后孙用了同样的Hash算法对信的内容作了一次哈希处理，得到另外一个哈希值B；</p><p>对比A和B，如果这两个值是相同的，那么可以确认：</p><ol><li><p>信就是小周本人写的。</p><p>如果是小王冒充写的，虽然小王能算出明文的哈希值C(C==B)，但没有用小周的私钥加密，用小周的公钥解密后肯定得不到哈希值A，与哈希值B匹配不上。</p></li><li><p>内容没有被篡改过。</p><p>如果内容被篡改过，经过公钥解密无法还原，自然无法和用同样的Hash算法算出的哈希值B匹配上。</p></li></ol></li></ol><p>问题4：此时，另外一种复杂的情况出现了：小周是通过网络把公钥寄送给他的三个好朋友的，有一个不怀好意的家伙小王劫持了小周与孙的通信并把公钥换成了自己的公钥发给孙，然后开始伪装成小周跟孙通信，小孙感觉通信的对象不像是小周，但是他又无法确认。</p><p>解决4：小周最终发现了自己的公钥被小王截断了，他感觉自己的公钥通过网络传输给自己的小伙伴似乎也是不安全的，不怀好意的家伙可以截断并篡改这个明文传输的公钥。</p><p>为此他想到了去第三方权威机构“证书中心”（certificate authority，简称CA）做认证。CA用自己的私钥对小周的公钥和其它信息做了一次加密。然后告诉小周：你用我这个来传递你的公钥吧！我担保没问题！</p><p>这样小周通过网络将数字证书传递给他的小孙后，小孙用CA给的公钥解密证书，这样就可以安全获取小周的公钥了。</p><p><strong>说明：问题3的防篡改解决方法，是建立在小孙已经获得了小周的公钥，因此可以通过签名机制，对通信方进行认证；而这里，小孙还没获得小周的公钥呢，公钥都被人替换了…因此需要引入额外的CA机制来做担保人</strong></p><h2 id="HTTPS通信过程"><a href="#HTTPS通信过程" class="headerlink" title="HTTPS通信过程"></a>HTTPS通信过程</h2><p>通过小周与他的小伙伴的通信，我们已经可以大致了解一个安全通信的过程，也可以了解基本的加密、解密、认证等概念。HTTPS就是基于这样一个逻辑设计的。</p><p>首先看看组成HTTPS的协议：HTTP协议和SSL/TLS协议。HTTP协议就不用讲了，而SSL/TLS就是负责加密解密等安全处理的模块，所以HTTPS的核心在SSL/TLS上面。整个通信如下：</p><ol><li><p>浏览器往服务器的443端口发起请求，请求携带了浏览器支持的加密算法和哈希算法。</p></li><li><p>服务器收到请求，选择浏览器支持的加密算法和哈希算法。</p></li><li><p>服务器将数字证书返回给浏览器，这里的数字证书可以是向某个可靠机构申请的，也可以是自制的。</p></li><li><p>浏览器进入数字证书认证环节，这一部分是浏览器内置的TLS完成的：</p><p>4.1 首先浏览器会从内置的证书列表中索引，找到服务器下发证书对应的机构，如果没有找到，此时就会提示用户该证书是不是由权威机构颁发，是不可信任的。如果查到了对应的机构，则取出该机构颁发的公钥。</p><p>4.2 用机构的证书公钥解密数字证书，得到证书的内容和证书签名。内容包括网站的网址、网站的公钥、证书的有效期等。浏览器会先用hash算法验证证书签名的合法性（验证过程类似上面小周和孙防止伪装和篡改的通信）。签名通过后，浏览器验证证书记录的网址是否和当前网址是一致的，不一致会提示用户。如果网址一致会检查证书有效期，证书过期了也会提示用户。这些都通过认证时，浏览器就可以安全使用证书中的网站公钥了。</p><p>4.3 浏览器生成一个随机数R，并使用网站公钥对R进行非对称加密。</p></li></ol><p>5、浏览器将加密的R传送给服务器。</p><p>6、服务器用自己的私钥非对称解密得到R。</p><p>7、服务器以R为密钥使用了<strong>对称加密算法</strong>加密网页内容并传输给浏览器（之前浏览器请求携带的支持的加密算法）。</p><p>8、浏览器以R为密钥使用之前约定好的解密算法获取网页内容。</p><p>重复7-8，双方采用<code>会话秘钥</code>进行<strong>加密通信</strong>。</p><p><img src=".%5Chttps%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%5Chttps.jpg" alt=""></p><p><strong>备注1</strong>：前5步其实就是HTTPS的握手过程，这个过程主要是认证服务端证书（内置的公钥）的合法性。因为非对称加密计算量较大，<strong>整个通信过程只会用到一次非对称加密算法</strong>（主要是用来保护传输客户端生成的用于对称加密的随机数私钥）。<strong>后续内容的加解密都是通过一开始约定好的对称加密算法进行的。</strong></p><p><strong>备注2</strong>：SSL/TLS是HTTPS安全性的核心模块，SSL是TLS的前身，SSL3.1就是TLS1.0，SSL3.2 -&gt; TLS1.1，SSL3.3 -&gt; TLS1.2</p><p>SSL/TLS是建立在TCP协议之上，因而也是应用层级别的协议。其包括TLS Record Protocol和TLS Handshaking Protocols两个模块，前者保证数据传输过程中的完整性和私密性，后者负责握手过程中的身份认证。</p><p>参考：</p><p><a href="https://blog.csdn.net/wangtaomtk/article/details/80917081" target="_blank" rel="noopener">深入浅出HTTPS工作原理_XINJing的专栏-CSDN博客_https原理</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Synchronized锁升级过程</title>
      <link href="/2021/08/25/synchronized-suo-sheng-ji-guo-cheng/"/>
      <url>/2021/08/25/synchronized-suo-sheng-ji-guo-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="Synchronized锁升级过程"><a href="#Synchronized锁升级过程" class="headerlink" title="Synchronized锁升级过程"></a>Synchronized锁升级过程</h1><p>在JDK 1.6之前,<code>synchronized</code>只有传统的锁机制（直接上重量级锁），因此给开发者留下了<code>synchronized</code>关键字相比于其他同步机制性能不好的印象。</p><p>在JDK 1.6引入了两种新型锁机制：偏向锁和轻量级锁，它们的引入是为了解决在没有多线程竞争或基本没有竞争的场景下因使用传统锁机制带来的性能开销问题。</p><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>Java是支持多线程的语言，因此在很多二方包、基础库中为了保证代码在多线程的情况下也能正常运行，也就是我们常说的线程安全，都会加入如<code>synchronized</code>这样的同步语义。但是在应用在实际运行时，很可能只有一个线程会调用相关同步方法。比如下面这个demo：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SyncDemo1</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SyncDemo1 syncDemo1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SyncDemo1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            syncDemo1<span class="token punctuation">.</span><span class="token function">addString</span><span class="token punctuation">(</span><span class="token string">"test:"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">addString</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>对于轻量级锁而言，每次调用addString时，加锁解锁都有一个CAS操作；对于重量级锁而言，加锁也会有一个或多个CAS操作（这里的’一个‘、’多个‘数量词只是针对该demo，并不适用于所有场景）。</p><p>在JDK1.6中为了<strong>提高一个对象在一段很长的时间内都只被一个线程用做锁对象场景下的性能</strong>，引入了偏向锁，在第一次获得锁时，会有一个CAS操作，之后该线程再获取锁，只会执行几个简单的命令，而不是开销相对较大的CAS命令。我们来看看偏向锁是如何做的。</p><h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h3><p>当我们新创建一个对象的时候：</p><p>如果JVM启用了偏向锁模式（jdk1.6以上是默认启用的）</p><p>并且对象所属的class没有关闭偏向锁模式（什么时候会关闭一个class的偏向模式下文会说，默认所有class的偏向模式都是是开启的）</p><p>那新创建对象的mark word中的锁状态有两种情况：</p><ol><li><p>Java没有禁用偏向延迟（默认），即程序刚启动创建的对象是不会开启偏向锁的，几秒延迟后，创建的对象才会开启偏向锁的。此时的对象，对象头中mark word中的锁状态就是无锁态（即最后三位是001）</p></li><li><p>通过<code>-XX:BiasedLockingStartupDelay=0</code>关闭延迟开启偏向锁</p><p>那新创建的对象一开始就是可偏向而未偏向状态（即最后三位是101，且此时mark word中的thread id为0，表示未偏向任何线程）。我们称之为匿名偏向(anonymously biased)</p></li></ol><h3 id="加锁过程"><a href="#加锁过程" class="headerlink" title="加锁过程"></a>加锁过程</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">if</span> <span class="token punctuation">(</span>该对象第一次被线程获得锁<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># case 1</span>    通过CAS操作<span class="token punctuation">(</span>比较手动构造的匿名偏向的mark word，和实际对象头的mark word是否相同，如果相同，就将mark word更新成线程    id的版本<span class="token punctuation">)</span>的结果是成功的，发现确实是处于匿名偏向状态，并将mark word中的thread id由<span class="token number">00</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">0</span>改成当前线程Id。如果成功，      则代表获得了偏向锁，继续执行同步块中的代码。<span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>当该对象第二次被线程获得锁的时候，并且发现锁对象偏向的就是当前线程<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># case 2</span>        在通过一些额外的检查后（细节见后面的文章），会往当前线程的栈中添加一条Displaced Mark Word为空的Lock                 Record中，然后继续执行同步块的代码，因为操纵的是线程私有的栈，因此不需要用到CAS指令；由此可见偏向锁模式下，当被        偏向的线程再次尝试获得锁时，仅仅进行几个简单的操作就可以了，在这种情况下，synchronized关键字带来的性能开销基        本可以忽略。    <span class="token keyword">if</span> <span class="token punctuation">(</span>当该对象第二次被线程获得锁的时候，发现已经偏向了其他线程<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># case 3</span>        则会进入到<span class="token operator">**</span>撤销偏向锁，膨胀为轻量级锁<span class="token operator">**</span>的逻辑里，一般来说，会在safepoint中去查看偏向的线程是否还存活，如果存活且还在同步块中         则将锁升级为轻量级锁，原偏向的线程继续拥有锁，当前线程则走入到锁升级的逻辑里；如果偏向的线程已经不存活或者不在同         步块中，则将对象头的`mark word`改为无锁状态（unlocked），之后再升级为轻量级锁。</code></pre><p>实际代码：</p><pre class=" language-c++"><code class="language-c++">/**1.mark->has_bias_pattern()是否为true，含义是 Java有没有把偏向延迟禁用2.cmpxchg_ptr方法第一个参数是预期修改后的值，第2个参数是修改的对象，第3个参数是预期原值，方法返回实际原值，如果等于预期原值则说明修改成功。*/CASE(_monitorenter): {  // lockee 就是锁对象  oop lockee = STACK_OBJECT(-1);  // derefing's lockee ought to provoke implicit null check 非空检查  CHECK_NULL(lockee);  // code 1：找到一个空闲的Lock Record  BasicObjectLock* limit = istate->monitor_base();  BasicObjectLock* most_recent = (BasicObjectLock*) istate->stack_base();  BasicObjectLock* entry = NULL;  while (most_recent != limit ) {    if (most_recent->obj() == NULL) entry = most_recent;    else if (most_recent->obj() == lockee) break;    most_recent++;  }  //entry不为null，代表还有空闲的Lock Record  if (entry != NULL) {    // code 2：将Lock Record的obj指针指向锁对象 也就是说不管是偏向锁还是轻量级锁 都要在当前线程的栈中分配一个Lock Record    entry->set_obj(lockee);    int success = false;    uintptr_t epoch_mask_in_place = (uintptr_t)markOopDesc::epoch_mask_in_place;    // markoop即对象头的mark word    markOop mark = lockee->mark();    intptr_t hash = (intptr_t) markOopDesc::no_hash;    // code 3：如果锁对象的mark word的状态是偏向模式    if (mark->has_bias_pattern()) {      uintptr_t thread_ident;      uintptr_t anticipated_bias_locking_value;      thread_ident = (uintptr_t)istate->thread();     // code 4：这里有几步操作，下文分析      anticipated_bias_locking_value =        (((uintptr_t)lockee->klass()->prototype_header() | thread_ident) ^ (uintptr_t)mark) &        ~((uintptr_t) markOopDesc::age_mask_in_place);     // code 5：如果偏向的线程是自己且epoch等于class的epoch      if  (anticipated_bias_locking_value == 0) {        // already biased towards this thread, nothing to do        if (PrintBiasedLockingStatistics) {          (* BiasedLocking::biased_lock_entry_count_addr())++;        }        success = true;      }       // code 6：如果偏向模式关闭，则尝试撤销偏向锁      else if ((anticipated_bias_locking_value & markOopDesc::biased_lock_mask_in_place) != 0) {        markOop header = lockee->klass()->prototype_header();        if (hash != markOopDesc::no_hash) {          header = header->copy_set_hash(hash);        }        // 利用CAS操作将mark word替换为class中的mark word        if (Atomic::cmpxchg_ptr(header, lockee->mark_addr(), mark) == mark) {          if (PrintBiasedLockingStatistics)            (*BiasedLocking::revoked_lock_entry_count_addr())++;        }      }         // code 7：如果epoch不等于class中的epoch，则尝试重偏向      else if ((anticipated_bias_locking_value & epoch_mask_in_place) !=0) {        // 构造一个偏向当前线程的mark word        markOop new_header = (markOop) ( (intptr_t) lockee->klass()->prototype_header() | thread_ident);        if (hash != markOopDesc::no_hash) {          new_header = new_header->copy_set_hash(hash);        }        // CAS替换对象头的mark word          if (Atomic::cmpxchg_ptr((void*)new_header, lockee->mark_addr(), mark) == mark) {          if (PrintBiasedLockingStatistics)            (* BiasedLocking::rebiased_lock_entry_count_addr())++;        }        else {          // 重偏向失败，代表存在多线程竞争，则调用monitorenter方法进行锁升级          CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);        }        success = true;      }      else {        // try to bias towards thread in case object is anonymously biased        // CAS将偏向线程改为当前线程，如果当前是匿名偏向则能修改成功，否则进入锁升级的逻辑。        // 下面构建一个匿名偏向的mark word，尝试用CAS指令替换掉锁对象的mark word        markOop header = (markOop) ((uintptr_t) mark & ((uintptr_t)markOopDesc::biased_lock_mask_in_place |(uintptr_t)markOopDesc::age_mask_in_place |epoch_mask_in_place));        if (hash != markOopDesc::no_hash) {          header = header->copy_set_hash(hash);        }        markOop new_header = (markOop) ((uintptr_t) header | thread_ident);        // debugging hint        DEBUG_ONLY(entry->lock()->set_displaced_header((markOop) (uintptr_t) 0xdeaddead);)        if (Atomic::cmpxchg_ptr((void*)new_header, lockee->mark_addr(), header) == header) {           // CAS修改成功          if (PrintBiasedLockingStatistics)            (* BiasedLocking::anonymously_biased_lock_entry_count_addr())++;        }        else {          // 如果修改失败说明存在多线程竞争，所以进入monitorenter方法          CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);        }        success = true;      }    }    // 如果偏向线程不是当前线程或没有开启偏向模式等原因都会导致success==false    if (!success) {      // 轻量级锁的逻辑      //code 9: 构造一个无锁状态的Displaced Mark Word，并将Lock Record的lock指向它      markOop displaced = lockee->mark()->set_unlocked();      entry->lock()->set_displaced_header(displaced);      //如果指定了-XX:+UseHeavyMonitors，则call_vm=true，代表禁用偏向锁和轻量级锁      bool call_vm = UseHeavyMonitors;      // 利用CAS将对象头的mark word替换为指向Lock Record的指针      if (call_vm || Atomic::cmpxchg_ptr(entry, lockee->mark_addr(), displaced) != displaced) {        // 判断是不是锁重入        if (!call_vm && THREAD->is_lock_owned((address) displaced->clear_lock_bits())) {        //code 10: 如果是锁重入，则直接将Displaced Mark Word设置为null          entry->lock()->set_displaced_header(NULL);        } else {          CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);        }      }    }    UPDATE_PC_AND_TOS_AND_CONTINUE(1, -1);  } else {    // lock record不够，重新执行    istate->set_msg(more_monitors);    UPDATE_PC_AND_RETURN(0); // Re-execute  }}</code></pre><p>由此可见，偏向锁升级的时机为：当锁已经发生偏向后，只要有另一个线程尝试获得偏向锁，则该偏向锁就会升级成轻量级锁。当然这个说法不绝对，因为还有批量重偏向这一机制。</p><p>对于“如果偏向的线程已经不存活或者不在同步块中，则将对象头的<code>mark word</code>改为无锁状态（unlocked），之后再升级为轻量级锁”这句话，有些人会问：</p><p>为什么当mark word置为无锁状态之后，下次线程获得锁的时候直接就升级成为轻量级锁了，为什么不是还是偏向锁呢？？</p><p>我们从偏向锁的诞生背景来考虑。偏向锁之所以被提出来，是JVM的开发人员发现在很多场景下，加了synchronized的方法或代码块在运行过程中其实是单线程使用（比如一些工具类为了保证其提供方法的线程安全会加synchronized，但在我们的应用中可能就是单线程使用），所以JVM为了提高性能加入了偏向锁机制。</p><p>而当<code>mark word置为无锁状态之后</code>，就代表该锁对象已经被多个线程使用，已经不满足偏向锁的适用场景了。如果下次获得锁的时候还设置为偏向锁，那可能会有频繁的锁状态切换，导致性能比重量级锁还低。</p><h3 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h3><p>如果当前锁已偏向其他线程||epoch值过期||偏向模式关闭||获取偏向锁的过程中存在并发冲突，都会进入到<code>InterpreterRuntime::monitorenter</code>方法， 在该方法中会对偏向锁撤销和升级。</p><h3 id="解锁过程"><a href="#解锁过程" class="headerlink" title="解锁过程"></a>解锁过程</h3><p>当有其他线程尝试获得锁时，是根据遍历偏向线程的<code>lock record</code>来确定该线程是否还在执行同步块中的代码。因此偏向锁的解锁很简单，仅仅将栈中的最近一条<code>lock record</code>的<code>obj</code>字段设置为null。需要注意的是，偏向锁的解锁步骤中<strong>并不会修改对象头中的thread id。</strong></p><h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p>下图展示了锁状态的转换流程：</p><img src="\Synchronized锁升级过程\biasedLocking.jpg" alt="biasedLocking" style="zoom:150%;" />]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Synchronized </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的各种常量池</title>
      <link href="/2021/08/17/java-zhong-de-ge-chong-chang-liang-chi/"/>
      <url>/2021/08/17/java-zhong-de-ge-chong-chang-liang-chi/</url>
      
        <content type="html"><![CDATA[<h1 id="Java中的各种常量池"><a href="#Java中的各种常量池" class="headerlink" title="Java中的各种常量池"></a>Java中的各种常量池</h1><p>JVM常量池主要分为<strong>Class文件常量池、运行时常量池，全局字符串常量池，以及基本类型包装类对象常量池</strong>。下面分别来看看吧</p><h2 id="Class文件常量池"><a href="#Class文件常量池" class="headerlink" title="Class文件常量池"></a><strong>Class文件常量池</strong></h2><p>在《深入理解Java虚拟机》中，常常看到<code>常量</code>这个词的身影：</p><ul><li>在Java技术体系里面，固定可作为GC Roots的对象包括以下几种：<ol><li>在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。</li><li>…</li></ol></li><li>常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。字面量比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，主要包括下面几类常量：<ul><li>被模块导出或者开放的包（Package）</li><li>类和接口的全限定名（Fully Qualified Name）</li><li>字段的名称和描述符（Descriptor）</li><li>方法的名称和描述符</li><li>方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）</li><li>动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）</li></ul></li></ul><p>是不是觉得很抽象呢？我们来看几个具体的例子吧！</p><p>通过javac编译成.class文件后，可用javap -v查看编译后的文件。</p><p>class文件常量池主要存放两大常量：<strong>字面量和符号引用</strong>。</p><ul><li><p><strong>字面量</strong>：字面量接近java语言层面的常量概念，主要包括：</p><ul><li><p>文本字符串</p><p>也就是我们声明的： <code>public String s= &quot;abc&quot;;</code>中的<code>&quot;abc&quot;</code>。我们在例子中分别创建了一个String类型的实例变量和局部变量。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">JavaTest</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> String instanceVariable <span class="token operator">=</span> <span class="token string">"实例变量的字符串字面量"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> String <span class="token function">setValue</span><span class="token punctuation">(</span>String paremeterString<span class="token punctuation">)</span><span class="token punctuation">{</span>        String localVariable <span class="token operator">=</span> <span class="token string">"局部变量的字符串字面量"</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> instanceVariable <span class="token operator">+</span> localVariable<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>摘录出Constant pool:</p><pre><code> #27 = Utf8               实例变量的字符串字面量 ... #29 = Utf8               局部变量的字符串字面量 -------------------------------------------------- 字面量被引用： #2 = String             #27            // 实例变量的字符串字面量 #4 = String             #29            // 局部变量的字符串字面量</code></pre><p>可以看到，无论是作为实例变量的字符串字面量，还是方法中定义的作为局部变量的字符串字面量，都保存到了类文件的常量池中。</p></li><li><p>基本类型的字面量</p><p>我们先来看一张表。表中记录了将不同类型的变量，根据值的取值范围，加载到操作数栈上的指令。</p><p>我们需要注意 ldc 这条指令用于加载常量池中的常量值，例如 ldc #18 将加载常量池中的第 18 项。因此我们不难推断，凡是取值范围和 ldc 指令相匹配的基本类型字面量，都需要保存到类文件常量池中。 下面我们来一一验证。</p><p><img src="C:%5CUsers%5C%E6%8F%90%E9%AB%98%E7%9F%A5%E8%AF%86%E6%B0%B4%E5%B9%B3%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210817180407881.png" alt="image-20210817180407881"></p><p>代码示例如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">JavaTest</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> instance_notldc <span class="token operator">=</span> <span class="token number">300</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> instance_ldc <span class="token operator">=</span> <span class="token number">32770</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 在常量池中存了</span>    <span class="token keyword">final</span> <span class="token keyword">int</span> instance_notldc_final <span class="token operator">=</span> <span class="token number">400</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 在常量池中存了</span>    <span class="token keyword">final</span> <span class="token keyword">int</span> instance_ldc_final <span class="token operator">=</span> <span class="token number">32771</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 在常量池中存了</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> static_int <span class="token operator">=</span> <span class="token number">500</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">int</span> final_static <span class="token operator">=</span> <span class="token number">600</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 在常量池中存了</span></code></pre></li></ul></li></ul><pre><code>    public void setValue(int v){        int local_notldc = 100;        int local_ldc = 32768;  // 在常量池中存了        final int local_notldc_final = 200;        final int local_ldc_final = 32769;  // 在常量池中存了    }}```摘录出Constant pool:```#3 = Integer            32770...#6 = Integer            32771...#8 = Integer            32768#9 = Integer            32769...#18 = Integer            400...#22 = Integer            600```可以看到：- 如果不加任何修饰符，int 类型变量的字面量如果超过 32767，就会保存到Class文件常量池中，供ldc指令使用。- 对于局部变量，final修饰符并没有起到作用；而实例变量加上final，就会保存到Class文件常量池中；- 单独使用static修饰符（类变量）并不会把字面量存到常量池中；【注】对于第一条，实例变量超过32767，会被构造函数中的ldc指令使用，所以也需要存进常量池。</code></pre><ul><li><p><strong>符号引用</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">JavaTest</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> String s <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">int</span> f <span class="token operator">=</span> <span class="token number">0x101</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setValue</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> temp <span class="token operator">+</span> v<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>符号引用主要设涉及编译原理方面的概念，包括下面三类常量:</p><ul><li><p>类和接口的全限定名，也就是java/lang/String;这样，将类名中原来的”.”替换为”/“得到的，主要用于在运行时解析得到类的直接引用，像上面的例子：</p><pre><code>#5 = Class              #33            // JavaDemo/JavaSE/JavaTest#6 = Class              #34            // java/lang/Object...#33 = Utf8               JavaDemo/JavaSE/JavaTest#34 = Utf8               java/lang/Object注意：这里用到了Object类的init方法：#1 = Methodref          #6.#29         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V#29 = NameAndType        #14:#15        // &quot;&lt;init&gt;&quot;:()V#14 = Utf8               &lt;init&gt;#15 = Utf8               ()V</code></pre></li><li><p>字段的名称和描述符，字段也就是类或者接口中声明的变量，包括类级别变量和实例级的变量：</p><pre><code>#2 = Fieldref           #5.#30         // JavaDemo/JavaSE/JavaTest.value:I#4 = Fieldref           #5.#32         // JavaDemo/JavaSE/JavaTest.s:Ljava/lang/String;</code></pre><pre><code>#30 = NameAndType        #7:#8          // value:I#7 = Utf8               value#8 = Utf8               I---------------------------------------------------------#32 = NameAndType        #9:#10         // s:Ljava/lang/String;#9 = Utf8               s#10 = Utf8               Ljava/lang/String;</code></pre><p>局部变量只保存字段名，但没有NameAndType引用到，更没有Fieldref的引用：</p><pre><code>#23 = Utf8               v#24 = Utf8               temp</code></pre></li><li><p>方法中的名称和方法描述符（参数类型+返回值）：</p><pre><code>#21 = Utf8               setValue#22 = Utf8               (I)V              // 参数int 返回void---------------------------------------------#25 = Utf8               getValue#26 = Utf8               ()I               // 无参数 返回int</code></pre></li></ul></li></ul><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池是方法区的一部分，所以也是全局贡献的，我们知道，jvm在执行某个类的时候，必须经过<strong>加载、链接（验证、准备、解析）、初始化</strong>，在第一步加载的时候需要完成：</p><ul><li>通过一个类的全限定名来获取此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个类对象，代表加载的这个类，这个对象是java.lang.Class的实例，它作为方法区这个类的各种数据访问的入口。</li></ul><p>类对象和普通对象是不同的，类对象是在类加载的时候完成的，是jvm创建的并且是单例的，作为这个类和外界交互的入口， 而普通的对象一般是在调用new之后创建。</p><p>上面的第二条，将class字节流代表的静态存储结构转化为方法区的运行时数据结构，其中就包含了class文件常量池进入运行时常量池的过程，<strong>运行时常量池是每个类私有的</strong>。</p><p>运行时常量池的作用是存储class文件常量池中的符号信息，运行时常量池中保存着一些class文件中描述的符号引用，同时在类的解析阶段还会将这些符号引用翻译出直接引用（直接指向实例对象的指针，内存地址），翻译出来的直接引用也是存储在运行时常量池中。</p><p>运行时常量池相对于class常量池一大特征就是具有动态性，java规范并不要求常量只能在运行时才产生，也就是说运行时常量池的内容并不全部来自class常量池，在运行时可以通过代码生成常量并将其放入运行时常量池中，这种特性被用的最多的就是String.intern()。</p><h2 id="全局字符串常量池"><a href="#全局字符串常量池" class="headerlink" title="全局字符串常量池"></a>全局字符串常量池</h2><p>HotSpot VM里，记录interned string的一个全局表叫做StringTable，它本质上就是个HashSet<String>。这是个纯运行时的结构，而且是惰性（lazy）维护的。注意它只存储对java.lang.String实例的引用，而不存储String对象的内容。 注意，它只存了引用，根据这个引用可以得到具体的String对象。</p><p>一般我们说一个字符串进入了全局的字符串常量池其实是说在这个StringTable中保存了对它的引用，反之，如果说没有在其中就是说StringTable中没有对它的引用。</p><p>在类加载阶段， JVM会在堆中创建对应这些 class 文件常量池中的字符串对象实例 ，并在字符串常量池中驻留其引用。具体在resolve阶段执行。这些常量全局共享。但是并不是大家想的那样，立即就创建对象并且在字符串常量池中驻留了引用。 <strong>JVM规范里明确指定resolve阶段可以是lazy的。</strong></p><p>JVM规范里Class文件的常量池项的类型，有两种东西：</p><ol><li><p>CONSTANT_Utf8</p></li><li><p>CONSTANT_String</p></li></ol><p>后者是String常量的类型，但它并不直接持有String常量的内容，而是只持有一个index，这个index所指定的另一个常量池项必须是一个CONSTANT_Utf8类型的常量，这里才真正持有字符串的内容。  </p><p>在HotSpot VM中，运行时常量池里：</p><p>CONSTANT_Utf8 -&gt; Symbol*（一个指针，指向一个Symbol类型的C++对象，内容是跟Class文件同样格式的UTF-8编码的字符串）<br>CONSTANT_String -&gt; java.lang.String（一个实际的Java对象的引用，C++类型是oop）</p><p>其中 CONSTANT_Utf8 会在类加载的过程中就全部创建出来，而<strong>CONSTANT_String则是lazy resolve的，例如说在第一次引用该项的ldc指令被第一次执行到的时候才会resolve</strong>。那么在尚未resolve的时候，HotSpot VM把它的类型叫做JVM_CONSTANT_UnresolvedString，内容跟Class文件里一样只是一个index；等到resolve过后这个项的常量类型就会变成最终的JVM_CONSTANT_String，而内容则变成实际的那个oop。</p><p>看到这里想必也就明白了， 就HotSpot VM的实现来说，加载类的时候，那些字符串字面量会进入到当前类的运行时常量池，不会进入全局的字符串常量池（即在StringTable中并没有相应的引用，在堆中也没有对应的对象产生）</p><p>看下面这个例子：</p><pre><code>class Test{    public static void main(String[] args){        String str1 = &quot;Hello&quot;;        String str2 = new String(&quot;World&quot;);    }}</code></pre><p>当运行中的程序使用到Test类的时候，Test.class文件的信息就会被加载到内存的方法区里。class文件常量池里大部分数据会被加载到“运行时常量池”。<strong>但String不是</strong>。例子中的”Hello”的一个引用会被存到同样在Non Heap区的字符串常量池（String Pool）里。而“Hello”本体还是和所有对象一样，创建在Heap堆区。R大的文章里，测试的结果是在新生代的Eden区。但因为一直有一个引用驻留在字符串常量池，所以不会被GC清理掉。这个Hello对象会生存到整个线程结束。如下图所示，字符串常量池的具体位置在JDK 7之前是在过去说的永生代里，JDK 7开始Hotspot把Interned String从永久代挪到Heap堆，JDK 8又彻底取消了永久代。但不管怎样，基本原理还是不变的。</p><p>同样的，”World”这个字面量也会在堆中创建一个字符串对象，并在字符串常量池中保存这个对象的一个引用。</p><p><img src="https://pic4.zhimg.com/e368cf97fe6c9e73fa87286e1cc0602a_r.jpg" alt="preview"></p><p>等主线程开始创建str1变量的时候，虚拟机就会到字符串常量池里找，看有没有能equals(“Hello”)的String。如果找到了，就在栈区当前栈帧的局部变量表里创建str1变量，然后把字符串常量池里对Hello对象的引用复制给str1变量。找不到的话，才会在heap堆重新创建一个对象，然后把引用驻留（intern）到字符串常量区。然后再把引用复制栈帧的局部变量表。</p><p><img src="https://pica.zhimg.com/20568a6ad0ef2860746533595e400716_r.jpg" alt="preview"></p><p>但如果是用new关键字来创建字符串，情况就不一样了</p><pre><code>class Test{    public static void main(String[] args){        String str1 = &quot;Hello&quot;;        String str2 = &quot;Hello&quot;;        String str3 = new String(&quot;Hello&quot;);    }}</code></pre><p><img src="https://pic4.zhimg.com/fe6b27f35b5491eb562138eda573c238_r.jpg" alt="preview"></p><p>这时候，str1和str2还是和之前一样。但str3因为new关键字会在Heap堆申请一块全新的内存，来创建新对象。虽然字面还是”Hello”，但是完全不同的对象，有不同的内存地址。</p><p>并且我们可以看一下String构造函数的源码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">String</span><span class="token punctuation">(</span>String original<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> original<span class="token punctuation">.</span>value<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>hash <span class="token operator">=</span> original<span class="token punctuation">.</span>hash<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>可以说是纯纯的复制关系，而不是在新的String对象中引用原来的字面量对应的对象。</p><p>参考：</p><ol><li><p>作者：胖君<br>链接：<a href="https://www.zhihu.com/question/22739143/answer/113822382" target="_blank" rel="noopener">Java里<em>String</em> a = <em>new</em> <em>String</em>(“abc”);这会在堆和栈里面分别创建对象abc吗?</a></p></li><li><p>R大 <a href="https://www.iteye.com/blog/rednaxelafx-774673" target="_blank" rel="noopener">请别再拿“String s = new String(“xyz”);创建了多少个String实例”来面试了吧 - Script Ahead, Code Behind - ITeye博客</a></p></li><li><p><a href="https://www.zhihu.com/question/55994121/answer/147296098" target="_blank" rel="noopener">(14 封私信 / 80 条消息) Java 中new String(“字面量”) 中 “字面量” 是何时进入字符串常量池的? - 知乎 (zhihu.com)</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> class文件常量池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM垃圾回收</title>
      <link href="/2021/08/16/jvm-la-ji-hui-shou/"/>
      <url>/2021/08/16/jvm-la-ji-hui-shou/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM垃圾回收"><a href="#JVM垃圾回收" class="headerlink" title="JVM垃圾回收"></a>JVM垃圾回收</h1><p>对于JVM的垃圾回收机制，我们主要关心以下三个问题：</p><ol><li>哪些内存需要回收？</li><li>什么时候可以回收？</li><li>具体怎么回收？</li></ol><p>下面就这几个问题分别进行讨论。</p><h2 id="哪些内存需要回收？"><a href="#哪些内存需要回收？" class="headerlink" title="哪些内存需要回收？"></a>哪些内存需要回收？</h2><p>首先，我们需要分清JVM中哪些运行时区域需要内存回收。</p><ul><li><p>程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭。程序计数器自不用说；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由JIT编译器进行一些优化，但在本章基于概念模型的讨论中，大体上可以认为是编译期可知的）。</p><p>因此，这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。</p></li><li><p>而Java堆和方法区则不一 样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存，本章后续讨论中的“内存”分配与回收也仅指这一部分内存。</p></li></ul><h3 id="堆内存回收"><a href="#堆内存回收" class="headerlink" title="堆内存回收"></a>堆内存回收</h3><p>在堆里面存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一 件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”（即不可能再被任何途径 使用的对象）。</p><p>引用计数算法（Reference Counting）是一种实现简单的算法，但很难解决对象 之间相互循环引用的问题，因此主流的Java虚拟机没有选用引用计数算法来管理内存，而是可达性分析算法。</p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>在主流的商用程序语言（Java、C#，甚至包括前面提到的古老的Lisp）的主流实现中， 都是称通过可达性分析（Reachability Analysis）来判定对象是否存活的。这个算法的基本思 路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所 走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连 （用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。</p><p>在Java语言中，可作为GC Roots的对象包括下面几种： </p><ol><li>虚拟机栈（栈帧中的本地变量表）中引用的对象（作为局部变量的引用）。 </li><li>方法区中类静态属性引用的对象（作为类变量的引用）。 </li><li>方法区中常量引用的对象（作为常量的引用）。 </li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象。</li></ol><h4 id="引用级别的扩充"><a href="#引用级别的扩充" class="headerlink" title="引用级别的扩充"></a>引用级别的扩充</h4><p>除了能将一个对象定义为“被引用”和“未被引用”这两种状态，我们还希望能描述这样一类对象：当内存空间还足够时，则能保留在内存之中；如果内存空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。 </p><p>在JDK 1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。</p><ul><li>强引用就是指在程序代码之中普遍存在的，类似“Object obj=new Object（）”这类的引 用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。 </li><li>软引用是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将 要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回 收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实 现软引用。</li><li>弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的 对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够， 都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了WeakReference类来实现弱引 用。 </li><li>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引 用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一 个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在 JDK 1.2之后，提供了PhantomReference类来实现虚引用</li></ul><h4 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a><del>finalize()方法</del></h4><p>通过覆盖finalize()方法，对象有机会在被回收之前，将自己与引用链上的任何一个对象建立关联（譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量），从而逃脱被回收的命运。</p><p>但不鼓励大家使用这种方法来拯救对象。它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。</p><h3 id="方法区内存回收"><a href="#方法区内存回收" class="headerlink" title="方法区内存回收"></a>方法区内存回收</h3><p>很多人认为方法区是没有垃圾收集的，Java虚拟机规范中确实没有要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集 的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以 回收70%～95%的空间，而方法区的垃圾收集效率远低于此。</p><p>方法区的垃圾收集主要回收两部分内容：废弃常量和无用的类。</p><ul><li><p>回收废弃常量主要是运行时常量池中的类（接口）、方法、字段的符号引用。</p></li><li><p>判定一个类是是“无用的类”需要同时满足下面3个条件： </p><ol><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。 </li><li>加载该类的ClassLoader已经被回收。 </li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该 类的方法。 </li></ol><p>虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是 和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc 参数进行控制。</p><p>在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p></li></ul><h2 id="什么时候可以回收？"><a href="#什么时候可以回收？" class="headerlink" title="什么时候可以回收？"></a>什么时候可以回收？</h2><h4 id="OopMap"><a href="#OopMap" class="headerlink" title="OopMap"></a>OopMap</h4><p>首先让我们引入OopMap的概念。</p><p>从可达性分析中从GC Roots节点找引用链这个操作为例，可作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中，现 在很多应用仅仅方法区就有数百兆，如果要逐个检查这里面的引用，那么必然会消耗很多时间。</p><p>更要命的是，可达性分析对执行时间的敏感性还体现在GC停顿上。因为这项分析工作必须在一 个能确保一致性的快照中进行——这里“一致性”的意思是指在整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情况，该点不满足的话分析结果准确性就无法得到保证。这一点是导致GC进行时必须停顿所有 Java执行线程（Sun将这件事情称为“Stop The World”）的其中一个重要原因，即使是在号称 （几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。</p><p>由于目前的主流Java虚拟机使用的都是准确式GC（即JVM能准确的知道在某个内存地址上存放数据的类型，比如是个基本类型呢，还是个引用类型呢），所以当执行系统停顿下来后，并不需要一个不漏地检查完所有全局性的和执行上下文中的引用位置，虚拟机应当有办法直接得知哪些地方存放着对象引用。</p><p>在HotSpot的实现中，使用一组称为OopMap的数据结构来达到这个目的：在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样，GC在扫描时就可以直接得知这些信息了。</p><h4 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h4><p>在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举，但一个很现实的问 题随之而来：可能导致引用关系变化，或者说OopMap内容变化的指令非常多，如果为每一 条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本将会变得很 高。 实际上，HotSpot也的确没有为每条指令都生成OopMap，前面已经提到，只是在“特定的 位置”记录了这些信息，这些位置称为安全点（Safepoint），即程序执行时并非在所有地方都 能停顿下来开始GC，只有在到达安全点时才能暂停。Safepoint的选定既不能太少以致于让 GC等待时间太长，也不能过于频繁以致于过分增大运行时的负荷。所以，安全点的选定基 本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的——因为每条指令执行 的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，“长时间 执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有 这些功能的指令才会产生Safepoint。 对于Sefepoint，另一个需要考虑的问题是如何在GC发生时让所有线程（这里不包括执行 JNI调用的线程）都“跑”到最近的安全点上再停顿下来。这里有两种方案可供选择：抢先式 中断（Preemptive Suspension）和主动式中断（Voluntary Suspension），其中抢先式中断不需 要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程 中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机实现采 用抢先式中断来暂停线程从而响应GC事件。 而主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设 置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。 轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。下面代码清 单3-4中的test指令是HotSpot生成的轮询指令，当需要暂停线程时，虚拟机把0x160100的内存 页设置为不可读，线程执行到test指令时就会产生一个自陷异常信号，在预先注册的异常处 理器中暂停线程实现等待，这样一条汇编指令便完成安全点轮询和触发线程中断。</p><h4 id="安全区域：点到线"><a href="#安全区域：点到线" class="headerlink" title="安全区域：点到线"></a>安全区域：点到线</h4><p>使用Safepoint似乎已经完美地解决了如何进入GC的问题，但实际情况却并不一定。 Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是， 程序“不执行”的时候呢？所谓的程序不执行就是没有分配CPU时间，典型的例子就是线程处 于Sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全的地方去 中断挂起，JVM也显然不太可能等待线程重新被分配CPU时间。对于这种情况，就需要安全 区域（Safe Region）来解决。 安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方 开始GC都是安全的。我们也可以把Safe Region看做是被扩展了的Safepoint。 在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，那样，当 在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。在线程要离 开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完 成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为 止。 到此，笔者简要地介绍了HotSpot虚拟机如何去发起内存回收的问题，但是虚拟机如何 具体地进行内存回收动作仍然未涉及，因为内存回收如何进行是由虚拟机所采用的GC收集 器决定的，而通常虚拟机中往往不止有一种GC收集器。下面继续来看HotSpot中有哪些GC收集器。</p><h2 id="具体怎么回收？"><a href="#具体怎么回收？" class="headerlink" title="具体怎么回收？"></a>具体怎么回收？</h2><h3 id="理论方法"><a href="#理论方法" class="headerlink" title="理论方法"></a>理论方法</h3><p>从宏观来说，垃圾收集算法的设计有以下几种思路。</p><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如同它的名字一样，算法分 为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有 被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经介绍过了。之所以说它 是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其不足进行改进而得到 的。它的主要不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是 空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程 序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾 收集动作。</p><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按容 量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着 的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是 对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指 针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原 来的一半，未免太高了一点。</p><p>现在的商业虚拟机都采用这种收集算法来回收新生代，IBM公司的专门研究表明，新生 代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存 分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor [1]。 当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最 后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是 8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10% 的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每 次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里 指老年代）进行分配担保（Handle Promotion）。 内存的分配担保就好比我们去银行借款，如果我们信誉很好，在98%的情况下都能按时 偿还，于是银行可能会默认我们下一次也能按时按量地偿还贷款，只需要有一个担保人能保 证如果我不能还款时，可以从他的账户扣钱，那银行就认为没有风险了。内存的分配担保也 一样，如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时， 这些对象将直接通过分配担保机制进入老年代。关于对新生代进行分配担保的内容，在本章 稍后在讲解垃圾收集器执行规则时还会再详细讲解。</p><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的 是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中 所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。 根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程 仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存 活的对象都向一端移动，然后直接清理掉端边界以外的内存，“标记-整理”算法的示意图如 图3-4所示。</p><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</p><p>在新生代 中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。</p><p>而老年代中因为对象存活率高、没有额外空间 对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。</p><h3 id="收集器的具体实现"><a href="#收集器的具体实现" class="headerlink" title="收集器的具体实现"></a>收集器的具体实现</h3><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</p><p>Java 虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾收集器都可能会有很大差别，并且一般都会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器。</p><p>这里讨论的收集器基于JDK 1.7 Update 14之后的HotSpot虚拟机（在这个版本中正式提供了商用的G1收集器，之前G1仍处于实验状 态），这个虚拟机包含的所有收集器如图3-5所示。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java对象类型转换</title>
      <link href="/2021/08/16/java-dui-xiang-lei-xing-zhuan-huan/"/>
      <url>/2021/08/16/java-dui-xiang-lei-xing-zhuan-huan/</url>
      
        <content type="html"><![CDATA[<h1 id="Java对象类型转换"><a href="#Java对象类型转换" class="headerlink" title="Java对象类型转换"></a>Java对象类型转换</h1><p>将一个类型强制转换成另一种类型的过程被称为类型装换。而Java中的对象类型转换，必须是有继承关系的对象，而不能是任意类型的对象。</p><p>如果对不存在继承关系的对象进行强制类型转换，会抛出强制类型转换异常（java.lang.ClassCastException）。</p><p>Java 语言允许某个类型的引用变量引用子类的实例，而且可以对这个引用变量进行类型转换。Java 中引用类型之间的类型转换（前提是两个类是父子关系）主要有两种，分别是向上转型（upcasting）和向下转型（downcasting）。</p><h2 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h2><p>父类引用指向子类对象为向上转型，语法格式如下：</p><pre class=" language-java"><code class="language-java">FatherClass obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SonClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>其中，FatherClass 是父类名称或接口名称，SonClass 是子类名称。obj 是根据 SonClass 这个子类模板创建出的对象。</p><p>向上转型就是把子类对象直接赋给父类引用，不用强制转换。使用起来有以下几点注意事项：</p><ol><li>使用向上转型可以调用父类类型中的所有成员方法，但不能调用子类类型中特有的成员方法。</li><li>当出现子类重写的情况，最终运行效果看子类的具体实现。</li></ol><h2 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h2><p>子类引用指向父类对象，称为向下转型，需要强制转换。</p><p>强制向下转型有两种方式：</p><ul><li><p>不安全的向下转型：如<code>Dog dog = (Dog) new Animal();</code>编译通过，但运行会抛出异常；</p></li><li><p>安全的向下转型：先向上转型，再向下转型，如:</p><pre class=" language-java"><code class="language-java">Animal animal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> Dog dog <span class="token operator">=</span> <span class="token punctuation">(</span>Dog<span class="token punctuation">)</span> animal<span class="token punctuation">;</span></code></pre></li></ul><p>这样做有什么意义呢？见下面示例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Game</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">playGame</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"打开电脑"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Csgo</span> <span class="token keyword">extends</span> <span class="token class-name">Game</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">playGame</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">playGame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"射击！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">LoL</span> <span class="token keyword">extends</span> <span class="token class-name">Game</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">playGame</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">playGame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"补兵！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Player</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">playGame</span><span class="token punctuation">(</span>Game game<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//通过instanceof来判断</span>        <span class="token comment" spellcheck="true">//参数为猫类对象的向上转型</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>game <span class="token keyword">instanceof</span> <span class="token class-name">Csgo</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Csgo csgo <span class="token operator">=</span> <span class="token punctuation">(</span>Csgo<span class="token punctuation">)</span> game<span class="token punctuation">;</span>            csgo<span class="token punctuation">.</span><span class="token function">playGame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>game <span class="token keyword">instanceof</span> <span class="token class-name">LoL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            LoL lol <span class="token operator">=</span> <span class="token punctuation">(</span>LoL<span class="token punctuation">)</span> game<span class="token punctuation">;</span>            lol<span class="token punctuation">.</span><span class="token function">playGame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Player player <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Player</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 传入不同的子类对象，在调用playGame时隐式的进行了向上转型</span>        player<span class="token punctuation">.</span><span class="token function">playGame</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Csgo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"*******************"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        player<span class="token punctuation">.</span><span class="token function">playGame</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LoL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>C<span class="token operator">:</span>\code\ide\java\jdk1<span class="token number">.8</span>\bin\java<span class="token punctuation">.</span>exe <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>打开电脑射击！<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>打开电脑补兵！</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发（一）线程安全与共享资源</title>
      <link href="/2021/07/06/java-bing-fa-yi-xian-cheng-an-quan-yu-gong-xiang-zi-yuan/"/>
      <url>/2021/07/06/java-bing-fa-yi-xian-cheng-an-quan-yu-gong-xiang-zi-yuan/</url>
      
        <content type="html"><![CDATA[<h1 id="Java并发（一）线程安全与共享资源"><a href="#Java并发（一）线程安全与共享资源" class="headerlink" title="Java并发（一）线程安全与共享资源"></a>Java并发（一）线程安全与共享资源</h1><p>​    能够安全的同时被多个线程同时调用的代码叫做<code>线程安全</code>。一段代码是<code>线程安全</code>的，等价于这段代码不包含<code>race conditions</code>（竞争条件）。而竞争条件只可能发生在多个线程同时更新<code>共享资源</code>的时候。因此为了我们的<code>线程安全</code>，很有必要知道线程在执行的时候共享了哪些资源。</p><h2 id="本地原始类型变量（local-primitive-variables）"><a href="#本地原始类型变量（local-primitive-variables）" class="headerlink" title="本地原始类型变量（local primitive variables）"></a>本地原始类型变量（local primitive variables）</h2><p>本地变量指定义在方法体内的变量。本地变量存储在每个线程私有的线程栈中，线程之间不会共享线程栈中的变量。这代表着所有的<code>本地原始类型变量</code>是线程安全的。下面是<code>本地原始类型变量</code>的例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">demoMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> threadSafeInt <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    threadSafeInt<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="本地对象引用（local-object-references）"><a href="#本地对象引用（local-object-references）" class="headerlink" title="本地对象引用（local object references）"></a>本地对象引用（local object references）</h2><p>本地对象引用与本地原始类型变量略有不同。引用本身同样是存储在线程栈中，且不共享的。但引用的那个对象是存储在堆中的（所有的对象存储在堆中）因此如果有多个线程能够访问到这个对象，那么这个对象是共享资源，不是线程安全的。</p><h2 id="对象成员变量（Member-variables-fields）"><a href="#对象成员变量（Member-variables-fields）" class="headerlink" title="对象成员变量（Member variables / fields）"></a>对象成员变量（Member variables / fields）</h2><p>对象的成员变量和对象一起存储在堆中。因此如果两个线程调用同一个对象实例的同一个方法（最常见的：使用同一个runnable实例【注：runnable实例指实现Runnable接口的实现类的实例】创建线程，两个线程调用start()方法后调用的是同一个对象实例的run()方法），而这个方法更新了对象的成员变量，那这个方法不是线程安全的。因为多个线程在同时更新<code>共享资源</code>。下面是一个不太常见的例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SharedMemberVariable</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        NotThreadSafe shareInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NotThreadSafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span>shareInstance<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span>shareInstance<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">MyRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    NotThreadSafe instance <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">MyRunnable</span><span class="token punctuation">(</span>NotThreadSafe instance<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>instance <span class="token operator">=</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>instance<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"一段文本"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">NotThreadSafe</span> <span class="token punctuation">{</span>    StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// StringBuilder不是线程安全的</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>String text<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在这个例子中，虽然两个线程使用的是两个不同的Runnable实例，但在两个Runnable实例调用run()方法的时候，两个Runnable实例的this.instance指向的是堆中同一个NotThreadSafe对象：shareInstance。因此两个线程调用同一个对象实例(shareInstance)的同一个方法(add(String text)方法)，而这个方法更新了对象的成员变量(sb)，那这个方法不是线程安全的。</p><p>然而，如果两个线程是在不同的实例上同时调用的add()方法，就不会构成竞争条件，比如这样稍微改动一下：</p><pre class=" language-Java"><code class="language-Java">new Thread(new MyRunnable(new NotThreadSafe())).start();new Thread(new MyRunnable(new NotThreadSafe())).start();</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 内存模型（JMM）</title>
      <link href="/2021/06/23/java-nei-cun-mo-xing-jmm/"/>
      <url>/2021/06/23/java-nei-cun-mo-xing-jmm/</url>
      
        <content type="html"><![CDATA[<h1 id="Java并发（二）Java内存模型"><a href="#Java并发（二）Java内存模型" class="headerlink" title="Java并发（二）Java内存模型"></a>Java并发（二）Java内存模型</h1><p>JVM（Java virtual machine）是对一个完整的计算机的建模，所以自然包括一个内存模型-也就是本文介绍的Java内存模型（Java memory medel）</p><p>在JVM内部，Java内存模型将内存分成thread stacks和heap，逻辑上的内存模型如下图：</p><p><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-1.png" alt=""></p><p>每一个在JVM中运行的thread都有一个独立的thread stack，thread stack包含了一个线程执行到当前位置，调用了哪些方法的相关信息。thread stack在 Jakob Jenkov 的文章中也叫做call stack。按照我的理解，thread stack = 虚拟机栈（JVM内存结构的概念）。在线程执行的过程中，thread stack是一直变化的。</p><p>此外，thread stack中包含了此线程执行到当前位置时，调用过的所有方法中的所有local variables。两个线程执行同样的代码段，也会将这段代码中出现的local variables在自己的thread stack中独立的创建一份。而每个线程只能访问自己的thread stack，所以一个线程创建的local variables对其他的所有线程都不可见。</p><p>基本定义：</p><p>本地变量：local variable，表示方法内部定义的变量。</p><p>成员变量：member variable，表示一个类的成员变量，通过类的实例访问。</p><p>类变量（静态变量）：class variabe/static class variable：表示一个类的静态变量，通过类访问。</p><table><thead><tr><th align="center">变量类型</th><th align="center">存放位置</th></tr></thead><tbody><tr><td align="center">本地变量：原始类型</td><td align="center">完全存在线程栈中</td></tr><tr><td align="center">本地变量：引用类型</td><td align="center">本地变量（即引用）存在线程栈中，引用的对象存在heap中</td></tr><tr><td align="center">成员变量</td><td align="center">随着对象存在heap中</td></tr><tr><td align="center">类变量</td><td align="center">随着class definiton存在heap中</td></tr></tbody></table><p>由于原始类型 ( boolean, byte, short, char, int, long, float, double)的本地变量完全存放在线程栈中，所以一个线程的原始类型的本地变量完全不能和其他线程共享，只能通过<code>pass a copy</code>给别的线程。</p><p>而heap上存放的是你的Java应用创建的<code>所有对象</code>。</p><ul><li>无论是哪个线程创建的</li><li>也不管这个对象是分配给一个方法中的本地变量，还是分配给另一个对象的成员变量。</li></ul><p>heap上的对象能被所有线程访问（只要这个线程拥有这个对象的引用）。而一个线程拥有了一个对象的访问权，也就拥有了这个对象的成员变量的访问权。因此如果两个线程同时调用同一个对象的方法，那么这两个线程都可以访问这个对象的成员变量。（但两个线程会对本地变量做独立的拷贝）</p><p>下面是一个例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ShareThreadTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ShareThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"Thread1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread thread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ShareThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"Thread2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">ShareThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">methodA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> localVariable1 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        ShareObject localVariable2 <span class="token operator">=</span> ShareObject<span class="token punctuation">.</span>shareInstance<span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Thread:"</span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"localVariable2:"</span> <span class="token operator">+</span> localVariable2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// ... do more with local variables</span>        <span class="token function">methodB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Integer localVariable1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">998</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// ... do more with local variable</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">ShareObject</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> ShareObject shareInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ShareObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>output<span class="token operator">:</span>Thread<span class="token operator">:</span>Thread2localVariable2<span class="token operator">:</span>JavaDemo<span class="token punctuation">.</span>MultiThread<span class="token punctuation">.</span>ShareObject<span class="token annotation punctuation">@23cebe71</span>Thread<span class="token operator">:</span>Thread1localVariable2<span class="token operator">:</span>JavaDemo<span class="token punctuation">.</span>MultiThread<span class="token punctuation">.</span>ShareObject<span class="token annotation punctuation">@23cebe71</span>Process finished with exit code <span class="token number">0</span></code></pre><p>两个线程在执行run()方法的时候，会调用methodA()方法。methodA()方法声明了两个本地变量。因此任何线程在执行到methodA()方法时，会在自己的线程栈中独立的复制一份<code>localVariable1</code>和 <code>localVariable2</code>的拷贝。其中，由<code>localVariable1</code>拷贝出的变量是完全独立的，线程a看不到另一个线程b对线程b自己的<code>copy of localVariable1</code>做出的修改。</p><p>而在两个线程栈中，虽然也独立的拷贝了<code>localVariable2</code>，但这两个拷贝复制的是指向堆上同一个对象的引用。</p><p>注意在methodB()方法中，创建了一个<code>localVariable1</code>本地变量，它是一个Integer类型对象的引用。由于这个方法每次执行的时候都会创建一个新的Integer对象，因此两个线程执行到这个方法，会创建不同的Integer实例，然后把引用复制到线程栈中。</p><p>整个过程对应下图：</p><p><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-3.png" alt=""></p><h1 id="计算机硬件内存架构"><a href="#计算机硬件内存架构" class="headerlink" title="计算机硬件内存架构"></a>计算机硬件内存架构</h1><p>现代的计算机硬件内存架构与Java内部的内存模型不太一样。由于我们的应用最终是运行在真实的计算机内存中，所以我们需要了解通用的硬件内存架构，以及我们的Java内存模型是如何与它共同工作的。</p><p>下面是一张简化的现代计算机硬件架构图：</p><p><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-4.png" alt=""></p><p>现代计算机通常有多个CPU，每个CPU包括多个cores。总而言之，在一台现代计算机上，多个线程可能同时在执行（并行执行）。</p><p>通常</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发1-线程模型</title>
      <link href="/2021/06/01/java-bing-fa-1-xian-cheng-mo-xing/"/>
      <url>/2021/06/01/java-bing-fa-1-xian-cheng-mo-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="Java线程模型"><a href="#Java线程模型" class="headerlink" title="Java线程模型"></a>Java线程模型</h2><h3 id="什么是线程模型？为什么要有线程模型？"><a href="#什么是线程模型？为什么要有线程模型？" class="headerlink" title="什么是线程模型？为什么要有线程模型？"></a>什么是线程模型？为什么要有线程模型？</h3><blockquote><p>什么是线程模型</p></blockquote><p>Java字节码运行在JVM中，通过Java字节码创建的线程，我们叫它<code>JVM线程</code><br>JVM运行在各种操作系统上，当JVM想进行线程创建、线程回收的操作，需要进行操作系统级的系统调用，在操作系统中创建、回收真正的线程。这种“真正的线程”我们称为<code>操作系统线程</code><br>可以看出，<code>JVM线程</code>和<code>操作系统线程</code>存在着某种映射关系。这种映射关系（两种线程之间的规范和协议）叫做<code>线程模型</code></p><blockquote><p>为什么要有线程模型</p></blockquote><p>没有线程模型，难道你要手动调用操作系统的接口，直接对<code>操作系统线程</code>操作吗？<br>答案是：<code>抽象！</code><br>JVM为各种操作系统的原生线程进行了高级抽象，提供了统一的<code>JVM线程接口</code>给开发者使用，它不香吗？<br>之所以要学，是因为我们要知其然，还要知其所以然~</p><h3 id="线程模型分类"><a href="#线程模型分类" class="headerlink" title="线程模型分类"></a>线程模型分类</h3><ol><li>一对一<br>用户线程和内核线程一一对应<br>优点：简单、易用<br>缺点：内核创建线程是有上限的，进而影响用户线程的高并发。</li><li>多对一<br>多个用户线程对应一个内核线程<br>优点：扩展了用户线程的上限<br>缺点：一个用户线程进行系统调用并阻塞，会导致内核线程组内的所有线程都无法进行内核调用</li><li>多对多<br>缺点：复杂</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM基本架构</title>
      <link href="/2021/05/07/jvm-ji-ben-jia-gou/"/>
      <url>/2021/05/07/jvm-ji-ben-jia-gou/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-Virtual-Machine-JVM-基本架构"><a href="#Java-Virtual-Machine-JVM-基本架构" class="headerlink" title="Java Virtual Machine(JVM)基本架构"></a>Java Virtual Machine(JVM)基本架构</h1><p>JVM包含三个基本部分：</p><ol><li>Class Loader</li><li>Runtime Memory（Runtime Data Area）</li><li>Execution Engine</li></ol><p>下面分别介绍三个部分。</p><h2 id="Class-Loader"><a href="#Class-Loader" class="headerlink" title="Class Loader"></a>Class Loader</h2><p>在类加载过程中，分成三个阶段：加载、链接、初始化</p><h3 id="加载（Loading）"><a href="#加载（Loading）" class="headerlink" title="加载（Loading）"></a><strong>加载（Loading）</strong></h3><p>拿到一个类/接口的二进制表示（即字节码），Loading过程生成原本的类/接口，将class结构写入方法区。（未链接还不能使用）<br>Java中有三个内置的类加载器：</p><ul><li><code>Bootstrap Class Loader</code>: 这个是<code>root</code>类加载器，是<code>Extension Class Loader</code>的父类。<code>Bootstrap Class Loader</code>加载的是<code>Java</code>的标准包（<code>standard Java packages</code>），例如<code>java.lang</code>，<code>java.net</code>，<code>java.util</code>，<code>java.io</code>…<br>这些package在<code>rt.jar</code>文件中，还有一些核心库在<code>$JAVA_HOME/jre/lib</code>文件夹中。</li><li><code>Extension Class Loader</code>: 这个类加载器是<code>Bootstrap Class Loader</code>的子类，又是<code>Application Class Loader</code>的父类。<code>Extension Class Loader</code>加载的是位于<code>$JAVA_HOME/jre/lib/ext</code>文件夹中的，标准Java库的扩展。</li><li><code>Application Class Loader</code>: 最后一个类加载器<code>Application Class Loader</code>，是<code>Extension Class Loader</code>的子类，它加载<code>classpath</code>中的文件，而<code>classpath</code>默认设置为当前应用程序的文件夹。可以用命令行<code>-classpath</code>或<code>-cp</code>来修改<code>classpath</code>。<br>JVM使用<code>ClassLoader.loadClass()</code>方法来将类加载进内存。<br>JVM优先选择父类的类加载器（即：<code>Bootstrap Class Loader &gt; Extension Class Loader &gt; Application Class Loader</code>）当父类加载器找不到想要的类时，才会委托子类加载器去找。</li></ul><h3 id="链接（Linking）"><a href="#链接（Linking）" class="headerlink" title="链接（Linking）"></a><strong>链接（Linking）</strong></h3><p>当一个类被加载进内存，紧接着进行链接操作。链接操作有分为三个步骤。</p><h4 id="验证（Verification）"><a href="#验证（Verification）" class="headerlink" title="验证（Verification）"></a>验证（Verification）</h4><p>验证<code>.class</code>文件的结构正确性。通常指的是Java代码和虚拟机的Java版本是否匹配。</p><h4 id="准备（Preparation）"><a href="#准备（Preparation）" class="headerlink" title="准备（Preparation）"></a>准备（Preparation）</h4><p>在准备阶段，主要做了两件小事：</p><ol><li>JVM为类/接口中用<code>static</code>修饰的<strong>类变量分配内存</strong>，并用默认值初始化。<br>例如下面的代码：</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> enabled <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></code></pre><p>​    JVM在准备阶段会为类变量<code>enabled</code>分配内存，并用<code>boolean</code>类型的默认值<code>false</code>进行初始化操作。</p><ol start="2"><li><p>构造与该类相关联的<strong>方法表</strong>。</p><p>这个数据结构，便是 Java 虚拟机实现<code>动态绑定</code>的关键所在。下面我将以 invokevirtual 所使用的虚方法表（virtual method table，vtable）为例介绍方法表的用法。invokeinterface 所使用的接口方法表（interface method table，itable）稍微复杂些，但是原理其实是类似的。</p><p>方法表本质上是一个数组，每个数组元素指向一个当前类及其祖先类中<code>非私有</code>、<code>非final</code>的实例方法（<code>非static</code>）。</p><p>这些方法可能是具体的、可执行的方法，也可能是没有相应字节码的抽象方法。方法表满足两个特质：</p><ul><li><p>其一，子类方法表中包含<strong>父类方法表</strong>中的所有方法；（注意不是父类中的所有方法哦）</p><p>即：包含关系</p></li><li><p>其二，子类方法在方法表中的索引值，与它<strong>所重写的父类方法</strong>的索引值相同。</p><p>即：替换关系</p></li></ul><p>我们知道，方法调用指令中的符号引用会在执行之前解析成实际引用。</p><p>对于静态绑定的方法调用（重载）而言，实际引用将指向具体的目标方法。对于动态绑定的方法调用（重写，即多态）而言，实际引用则是方法表的索引值（实际上并不仅是索引值）。在执行过程中，Java 虚拟机将获取调用者的<code>实际类型</code>，并在该<code>实际类型的虚方法表</code>中，根据索引值获得目标方法。这个过程便是动态绑定。</p><p>让我们来看一个例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Passenger</span> <span class="token punctuation">{</span>  <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">passThroughImmigration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">ForeignerPassenger</span> <span class="token keyword">extends</span> <span class="token class-name">Passenger</span> <span class="token punctuation">{</span>   <span class="token annotation punctuation">@Override</span>   <span class="token keyword">void</span> <span class="token function">passThroughImmigration</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/* 进外国人通道 */</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">ChinesePassenger</span> <span class="token keyword">extends</span> <span class="token class-name">Passenger</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">void</span> <span class="token function">passThroughImmigration</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/* 进中国人通道 */</span> <span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">visitDutyFreeShops</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/* 逛免税店 */</span> <span class="token punctuation">}</span><span class="token punctuation">}</span>Passenger passenger <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token comment" spellcheck="true">// 多态，选择某个子类作为对象的实际类型</span>passenger<span class="token punctuation">.</span><span class="token function">passThroughImmigration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 根据调用者passenger的实际类型，并在该实际类型的虚方法表中，根据索引值获得目标方法</span></code></pre><img src="C:\Users\提高知识水平\AppData\Roaming\Typora\typora-user-images\image-20210813231035497.png" alt="image-20210813231035497" style="zoom: 80%;" /><p>在我们的例子中，Passenger 类的方法表包括两个方法：toString() 和 passThroughImmigration()，它们分别对应 0 号和 1 号。之所以方法表调换了 toString() 方法和 passThroughImmigration() 方法的位置，是因为 toString() 方法的索引值需要与 Object 类中同名方法的索引值一致。为了保持简洁，这里我就不考虑 Object 类中的其他方法。</p><p>ForeignerPassenger 的方法表同样有两行。其中，0 号方法指向继承而来的 Passenger 类的 toString() 方法。1 号方法则指向自己重写的 passThroughImmigration() 方法。</p><p>ChinesePassenger 的方法表则包括三个方法，除了继承而来的 Passenger 类的 toString() 方法，自己重写的 passThroughImmigration() 方法之外，<strong>还包括独有的 visitDutyFreeShops 方法</strong>。</p><pre class=" language-java"><code class="language-java">Passenger passenger <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>passenger<span class="token punctuation">.</span><span class="token function">passThroughImmigration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这里，JVM的工作可以想象为导航员。每当来了一个乘客需要出境，导航员会先问是中国人还是外国人（<code>获取动态类型</code>），然后翻出中国人 / 外国人对应的小册子（获取动态类型的方法表），小册子的第 1 页便写着应该如何办理手续（用 1 作为索引来查找方法表所对应的目标方法）。</p></li></ol><h4 id="解析（Resolution）"><a href="#解析（Resolution）" class="headerlink" title="解析（Resolution）"></a>解析（Resolution）</h4><p>在此阶段，将<code>符号引用</code>替换为在<code>运行时常量池</code>中存在的<code>直接引用</code>。</p><p>如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必触发这个类的链接以及初始化。）</p><p>此外，<strong>Java 虚拟机规范并没有要求在链接过程中完成解析</strong>。它仅规定了：如果某些字节码使用了符号引用，那么在执行这些字节码之前，需要完成对这些符号引用的解析。</p><h3 id="初始化（Initialization）"><a href="#初始化（Initialization）" class="headerlink" title="初始化（Initialization）"></a><strong>初始化（Initialization）</strong></h3><p>在 Java 代码中，如果要初始化一个静态字段，我们可以在声明时直接赋值，也可以在静态代码块中对其赋值。</p><ul><li><p>如果直接赋值的静态字段被 final 所修饰，并且它的类型是基本类型或字符串时，那么该字段便会被 Java 编译器标记成常量值（ConstantValue），其初始化直接由 Java 虚拟机完成。</p></li><li><p>除此之外的直接赋值操作，以及所有静态代码块中的代码，则会被 Java 编译器置于同一方法中，并把它命名为 &lt; clinit &gt;。随后执行类/接口的初始化方法（<code>&lt;clinit&gt;</code>）</p></li></ul><p>类加载的最后一步是初始化，便是为标记为常量值的字段赋值，以及执行 &lt; clinit &gt; 方法的过程。Java 虚拟机会通过加锁来确保类的 &lt; clinit &gt; 方法仅被执行一次，即在多线程情况下是安全的。<br>例如上面的例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> enabled <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></code></pre><p>类变量<code>enabled</code>在准备阶段被设置成<code>boolean</code>类型的默认值<code>false</code>，直到初始化阶段，才被标记成常量值，并由JVM直接赋予真正的值<code>true</code>。</p><p>只有当初始化完成之后，类才正式成为可执行的状态。那么，类的初始化何时会被触发呢？JVM 规范枚举了下述多种触发情况：</p><ol><li>当虚拟机启动时，初始化用户指定的主类；</li><li>当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类；</li><li>当遇到调用静态方法的指令时，初始化该静态方法所在的类；</li><li>当遇到访问静态字段的指令时，初始化该静态字段所在的类；</li><li>子类的初始化会触发父类的初始化；</li><li>如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；</li><li>使用反射 API 对某个类进行反射调用时，初始化这个类；</li><li>当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。</li></ol><p>下面代码是情况4的一个例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">LazyHolder</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> Singleton INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> LazyHolder<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这段代码是著名的单例延迟初始化例子:</p><p>只有当调用 Singleton.getInstance 时，程序才会访问 LazyHolder.INSTANCE，才会触发对 LazyHolder 的初始化（对应第 4 种情况），继而新建一个 Singleton 的实例。</p><p>由于类初始化是线程安全的，并且仅被执行一次，因此程序可以确保多线程环境下有且仅有一个 Singleton 实例。</p><h2 id="Runtime-Data-Area"><a href="#Runtime-Data-Area" class="headerlink" title="Runtime Data Area"></a>Runtime Data Area</h2><ol><li>方法区（Method Area）<br>存储所有类级别的数据，例如：运行时常量池、</li><li>堆区（Heap Area）</li><li>虚拟机栈（Stack Area）</li><li>本地方法栈（Native Method Stacks）</li><li>PC寄存器（Program Counter Registers）</li></ol><h2 id="Execution-Engine"><a href="#Execution-Engine" class="headerlink" title="Execution Engine"></a>Execution Engine</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论总结</title>
      <link href="/2020/07/05/gai-lu-lun-zong-jie/"/>
      <url>/2020/07/05/gai-lu-lun-zong-jie/</url>
      
        <content type="html"><![CDATA[<blockquote><h2 id="随机变量"><a href="#随机变量" class="headerlink" title="随机变量"></a>随机变量</h2></blockquote><h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><ol><li>随机现象：在一定的条件下，并不总是出现相同结果的现象称为随机现象。</li><li>随机试验：对在相同条件下可以重复的随机现象的观察、记录、试验称为随机试验。也有很多随机现象是不可重复的（例如：某场足球赛的胜负是无法重复的）。概率论与数理统计主要研究能大量重复的随机现象，但后者同样重要。</li><li>样本空间与样本点：随机现象的一切可能出现的基本结果组成的集合称为样本空间，记为 $ \Omega=\{\omega\} $，其中 $ \omega $ 为样本点，表示可能出现的基本结果。</li><li>随机变量：给定一个随机现象和它对应的样本空间，一个随机变量X给每个基本结果（样本点）赋予一个数值的值。Methematically,a random variable is a real-valued function of the experimental outcome.</li></ol><h3 id="二、易混淆概率对比"><a href="#二、易混淆概率对比" class="headerlink" title="二、易混淆概率对比"></a>二、易混淆概率对比</h3><h4 id="随机变量vs随机变量取值"><a href="#随机变量vs随机变量取值" class="headerlink" title="随机变量vs随机变量取值"></a>随机变量vs随机变量取值</h4><h4 id="PMF、PDF、CDF"><a href="#PMF、PDF、CDF" class="headerlink" title="PMF、PDF、CDF"></a>PMF、PDF、CDF</h4><ol><li>概念解释</li></ol><ul><li>PMF（probability mass function）概率质量函数：在概率论中，概率质量函数是<code>离散随机变量</code>在各特定取值上的概率。</li><li>PDF（probability density function）概率密度函数：<code>连续型随机变量</code>的概率密度函数（在不至于混淆时可以简称为密度函数）是一个描述这个随机变量的输出值，在某个确定的取值点附近的可能性的函数。</li><li>CDF（cumulative distribution function）累积分布函数：又叫分布函数，是<code>PDF</code>的积分/<code>PMF</code>的累加，能完整描述一个实随机变量X的概率分布。</li></ul><ol start="2"><li>数学表示<br>1) PMF<br>$$ p_X(x)=P(X=x) $$<br>2) PDF<br>$$ P(a \leqslant X \leqslant b)=\int_{a}^{b}f_X(x)dx $$<br>3) CDF</li></ol><ul><li>对于离散型随机变量</li><li>对于连续型随机变量<br>$$ F_X(x)=P(X \leqslant x)=\int_{-\infty }^{x}f_X(x)dx $$</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概率论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建博客基本用法</title>
      <link href="/2020/05/08/hexo-da-jian-bo-ke-ji-ben-yong-fa/"/>
      <url>/2020/05/08/hexo-da-jian-bo-ke-ji-ben-yong-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="发布新博客"><a href="#发布新博客" class="headerlink" title="发布新博客"></a>发布新博客</h2><ol><li>创建新博客<pre class=" language-bash"><code class="language-bash">hexo new post <span class="token string">"新的博客名"</span></code></pre>会在<code>C:\code\git\hhhOscar.github.io\source\_posts</code>目录下新创建一个<code>资源（图片）文件夹</code>和一个<code>.md</code>文件</li><li>发布博客<pre class=" language-bash"><code class="language-bash">hexo g     // 生成静态网页hexo s     // 本地预览效果hexo d     // 上传到Github上</code></pre></li></ol><h2 id="文章-Front-matter-介绍"><a href="#文章-Front-matter-介绍" class="headerlink" title="文章 Front-matter 介绍"></a>文章 Front-matter 介绍</h2><h3 id="Front-matter-选项详解"><a href="#Front-matter-选项详解" class="headerlink" title="Front-matter 选项详解"></a>Front-matter 选项详解</h3><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>cover</td><td><code>false</code></td><td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>keywords</td><td>文章标题</td><td>文章关键字，SEO 时需要</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><h3 id="最全示例"><a href="#最全示例" class="headerlink" title="最全示例"></a>最全示例</h3><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">title</span><span class="token punctuation">:</span> hexo搭建博客基本用法<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2020-05-08 13:10:25</span><span class="token key atrule">author</span><span class="token punctuation">:</span> RockZ<span class="token key atrule">img</span><span class="token punctuation">:</span> /source/images/xxx.jpg<span class="token key atrule">top</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">cover</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">coverImg</span><span class="token punctuation">:</span> /images/1.jpg<span class="token key atrule">password</span><span class="token punctuation">:</span> 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92<span class="token key atrule">toc</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">mathjax</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">summary</span><span class="token punctuation">:</span> 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要<span class="token key atrule">categories</span><span class="token punctuation">:</span> Markdown<span class="token key atrule">tags</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> Hexo  <span class="token punctuation">-</span> Github</code></pre><h2 id="代码块怎么写"><a href="#代码块怎么写" class="headerlink" title="代码块怎么写"></a>代码块怎么写</h2><h3 id="css实例"><a href="#css实例" class="headerlink" title="css实例"></a>css实例</h3><pre class=" language-css"><code class="language-css"><span class="token selector">pre </span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* padding: 1.5rem !important; */</span>    <span class="token property">padding</span><span class="token punctuation">:</span> <span class="token number">1.5</span>rem <span class="token number">1.5</span>rem <span class="token number">1.5</span>rem <span class="token number">3.3</span>rem <span class="token important">!important</span><span class="token punctuation">;</span>    <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">1</span>rem <span class="token number">0</span> <span class="token important">!important</span><span class="token punctuation">;</span>    <span class="token property">background</span><span class="token punctuation">:</span> <span class="token hexcode">#272822</span><span class="token punctuation">;</span>    <span class="token property">overflow</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>    <span class="token property">border-radius</span><span class="token punctuation">:</span> <span class="token number">0.35</span>rem<span class="token punctuation">;</span>    <span class="token property">tab-size</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">code </span><span class="token punctuation">{</span>    <span class="token property">padding</span><span class="token punctuation">:</span> <span class="token number">1</span>px <span class="token number">5</span>px<span class="token punctuation">;</span>    <span class="token property">font-family</span><span class="token punctuation">:</span> Inconsolata, Monaco, Consolas, <span class="token string">'Courier New'</span>, Courier, monospace<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* font-size: 0.91rem; */</span>    <span class="token property">color</span><span class="token punctuation">:</span> <span class="token hexcode">#e96900</span><span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token hexcode">#f8f8f8</span><span class="token punctuation">;</span>    <span class="token property">border-radius</span><span class="token punctuation">:</span> <span class="token number">2</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="如何在md文件中书写"><a href="#如何在md文件中书写" class="headerlink" title="如何在md文件中书写"></a>如何在md文件中书写</h3><pre><code>```cssyour code here```</code></pre><h3 id="支持语言"><a href="#支持语言" class="headerlink" title="支持语言"></a>支持语言</h3><p><a href="https://prismjs.com/#languages-list" target="_blank" rel="noopener">官方文档</a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank" rel="noopener">github上的hexo主题</a><br><a href="https://godweiyang.com/2018/04/13/hexo-blog/" target="_blank" rel="noopener">超详细Hexo+Github博客搭建小白教程</a><br><a href="https://segmentfault.com/a/1190000007261752?utm_source=sf-related" target="_blank" rel="noopener">Hexo下mathjax的转义问题</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/05/02/hello-world/"/>
      <url>/2020/05/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
